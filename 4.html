<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>NoSQL-Datenbanken - Kapitel 4 - Replikation und Sharding</title>

		<link rel="stylesheet" href="reveal.js/dist/reset.css">
		<link rel="stylesheet" href="reveal.js/dist/reveal.css">

        <link rel="stylesheet" href="src/slides.css">
        <link rel="stylesheet" href="src/sql.css">

		<link rel="stylesheet" href="src/layout.css">
        <link rel="stylesheet" href="lib/joint.min.css" />
        <link rel="stylesheet" href="src/erd.css" />
        <link rel="stylesheet" href="src/poll.css" />

		<!-- Theme used for syntax highlighting of code -->
		<script>
			if(window.location.search.match( /print-pdf/gi )) {
				document.getElementsByTagName("head")[0].innerHTML += '<link rel="stylesheet" href="src/routeros.css">';
			} else {
				document.getElementsByTagName("head")[0].innerHTML += '<link rel="stylesheet" href="src/rainbow.css">';
			}
		</script>

        <!--<script defer src="lib/fontawesome.all.min.js"/>-->
        <link href="lib/fontawesome.all.min.css" rel="stylesheet">
        <style> .reveal i.fa { font-family:FontAwesome; font-style: normal; } </style>
	</head>
	<body>
		<div class="reveal">
            <div id="header"></div>
            <div id="footer"></div>
			<div class="slides">
                <section>
                    <h4 style="text-align:center"><b>Prof. Dr.-Ing. Johannes Schildgen</b><br>
                    <a href="mailto:johannes.schildgen@oth-regensburg.de">johannes.schildgen@oth-regensburg.de</a></h4>
                    <h2>NoSQL-Datenbanken</h2>
                    <h4 style="text-align:center">&nbsp;</h4>
                    <h3>Kapitel 4: Replikation und Sharding</h3>
                    <h4 style="text-align:center">&nbsp;<br>&nbsp;</h4>
                    <img src="img/ccby.png" height="60px" style="position: absolute; left:0px; border:0; bottom:-160px;">
                    <img src="img/oth.png" height="60px" style="position: absolute; right:0px; border:0; bottom:-160px; box-shadow:none">
                </section>

                <section>
                    <h3>Replikation</h3>
						<p class="small" style="margin-top: -5mm;">Kopien derselben Daten werden auf mehreren Rechnern gespeichert.</p>
                        <p class="small">&Rightarrow; Hochverfügbarkeit (Fehlertoleranz gegenüber Ausfall einzelner Server)</p>
                        <h4>In MongoDB: Replica-Sets (Master-Slave-Replikation)</h4>
                        <ul class="small">
                            <li>Replica Set besteht aus N Knoten, die dieselben Daten speichern
                            <br>+ optional 1 Arbiter-Knoten (speichert keine Daten)</li>
                            <li>Jeder Knoten ist eine <code>mongod</code>-Instanz</li>
                            <li>1 Primary-Knoten (Master), der Rest Secondary-Knoten (Slaves)</li>
                        </ul>
                            <!--
                                <ul>
                                    <li>Primary: Schreiboperationen passieren hier,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leseoperationen standardmäßig auch.</li>
                                    <li>Secondary: Hier darf auch gelesen werden.</li>
                                </ul>
                            </li>-->

                            <div class="small"><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Primary</div></div>
                            <div class="columns small">
                                <div><h2 style="margin-top: -10mm; margin-bottom: -5mm; margin-left: 4cm;" class="">&swarr;</h2><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                                <div><h2 style="margin-top: -10mm; margin-bottom: -5mm; margin-left: -6cm;" class="">&searr;</h2><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                            </div>

                </section>
                
                <section>
                    <h3>Replikation starten und einrichten</h3>
                    <p class="small"><b>1. <code>mongod</code> auf den Replikas starten</b> (hier: 3x auf localhost)</p>
                    <pre><code class="bash">mongod --replSet "rs0" --port 27011 --dbpath /data/data1
mongod --replSet "rs0" --port 27012 --dbpath /data/data2
mongod --replSet "rs0" --port 27013 --dbpath /data/data3</code></pre>

                    <p class="small"><b>2. Auf irgendeinem der Replikas in der <code>mongo</code>-Shell Replikation initialisieren:</b></p>
                    <pre><code class="javascript">> rs.initiate( {
    _id : "rs0",
    members: [
        { _id: 0, host: "localhost:27011" },
        { _id: 1, host: "localhost:27012" },
        { _id: 2, host: "localhost:27013" }
    ]
})</code></pre>
<aside class="notes">In der Praxis laufen die einzelnen <code>mongod</code>-Instanzen natürlich jeweils auf verschiedenen Rechnern. Hier läuft zu Testzwecken alles auf localhost. Zum Initialisieren verbindet man sich mit einem beliebigen Replika (z. B. <code>mongo --port 27011</code>) und übergibt die Konfiguration des Replication-Sets. Wichtig ist, alle Replikas unter Angabe eines gemeinsamen Replika-Set-Namens (hier: <code>"rs0"</code>) zu starten und diesen Namen auch in der Konfiguration anzugeben.</aside>
                </section>

                <section>
                    <h3><code>rs.status()</code></h3>
                    <pre><code class="javascript" style="max-height: 30cm;">rs0:PRIMARY> rs.status()
{
    "set" : "rs0",
    "myState" : 1,     // 1: ich bin PRIMARY, 2: SECONDARY
    // ...
    "members" : [ 
    {    
        "_id" : 0,
        "name" : "localhost:27011",
        "state" : 1,
        "stateStr" : "PRIMARY",
        // ...
    }, 
    {
        "_id" : 1,
        "name" : "localhost:27012",
        "state" : 2,
        "stateStr" : "SECONDARY"
    }
    //...
</code></pre>

<aside class="notes">An dem <code>rs0:PRIMARY></code> bzw. <code>rs0:SECONDARY></code> in der Mongo-Shell erkennt man, ob man mit dem Primary oder einem Secondary verbunden ist. <code>rs.status()</code> zeigt die Konfiguration und den Zustand (sind Knoten offline? ...) der Replikation an.</aside>
                </section>

                <section>
                        <h3>Replikation in MongoDB</h3>
                        <div class="columns">
                            <div>
                                <h4 style="margin-bottom: -5mm;">Schreiboperationen</h4>
                                <p class="small">erfolgen auf dem Primary.</p>
                            </div>
                            <div>
                                <h4 style="margin-bottom: -5mm;">Leseoperationen</h4>
                                <p class="small">erfolgen standardmäßig auf dem Primary,
                                    <br>sind aber auch auf Secondaries möglich.
                                </p>
                            </div>
                        </div>

                        <pre style="width: 8cm; position: absolute; left: 2cm;" class="fragment"><code class="javascript">db.foo.insertOne(...)</code></pre>

                        <div class="small"><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Primary</div></div>
                        <div class="columns small">
                            <div><h2 style="margin-top: -10mm; margin-bottom: -5mm; margin-left: 4cm;" class="fragment">&swarr;</h2><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                            <div><h2 style="margin-top: -10mm; margin-bottom: -5mm; margin-left: -6cm;" class="fragment">&searr;</h2><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                        </div>

<div class="poll fragment" style="bottom:-120px" data-fragment-index="4">
    <h1>Warum wird auch standardmäßig vom Primary gelesen?</h1>
            <ul>
                    <li>Ist schneller</li>
                    <li data-poll="correct">Aktuellere Daten</li>
                    <li>Nur dort sind die Daten</li>
                    <li>Einfach nur so</li>
            </ul>
    <h2>https://fraage.de</h2>
</div>

                        <aside class="notes">Bei einer Master-Master- (oder Multi-Master-)Replikation dürfen mehrere Masterknoten existieren, auf die jeweils geschrieben werden darf und die sich gegenseitig synchronisieren. Da dadurch Inkonsistenzen und Konflikte entstehen können (Welches Write gewinnt?), ist ein gängiger Ansatz die Master-Slave-Replikation, so auch in MongoDB. In MongoDB wird der Master (PRIMARY) automatisch gewählt.</aside>
                </section>

                <section>
                    <h3><code>rs.secondaryOk()</code></h3>
                    <p class="small">Leseoperationen sind auf Secondaries nur mit slaveOk möglich:</p>
                    <pre><code class="javascript">rs0:SECONDARY> db.kunden.count()</code></pre>
                    <p class="small"><i class="red">"errmsg" : "not master and slaveOk=false"</i></p>
                    <div class="fragment">
                    <h4>rs.secondaryOk()</h4>
                    <p class="small">Keine Garantie für Strong Consistency.<br>Lesen noch nicht synchronisierter Daten möglich.</p>
                    <pre><code class="plaintext">rs0:SECONDARY> rs.secondaryOk()
rs0:SECONDARY> db.kunden.count()
3</code></pre>
</div>
<aside class="notes">Mit <code>db.secondaryOk()</code> gibt man das Einverständnis, möglicherweise veraltete Daten zu lesen. Es könnte ja sein, dass Dokumente eingefügt, geändert oder gelöscht wurden, diese Änderung aber noch nicht auf den Secondary, mit dem man gerade verbunden ist, synchronisiert wurde, z. B. wegen Netzwerkverzögerungen.</aside>
                </section>

               

                <section>
                    <h3>Strong vs. Eventual Consistency</h3>
                    <p class="small">ACID fordert Strong Consistency!</p>
                    <h4>Strong Consistency</h4>
                    <pre><code class="javascript">rs0:PRIMARY> db.kunden.count()
4   // das ist stets der tatsächliche aktuelle Wert!</code></pre>

<div class="fragment">
<h4>Eventual Consistency (eventual &wedgeq; schließlich)</h4>
                    <pre><code class="plaintext">rs0:SECONDARY> rs.secondaryOk()
rs0:SECONDARY> db.kunden.count()
3
rs0:SECONDARY> db.kunden.count()
3
rs0:SECONDARY> db.kunden.count()
4</code></pre></div>
<aside class="notes">Eine Möglichkeit, strong Consistency in MongoDB zu erreichen, also in jedem Fall aktuelle Daten zu lesen, ist das Lesen vom Primary. Eine andere Möglichkeit ist mittels eines Write-Concerns möglich (siehe übernächste Folie).</aside>
                </section>

                <section>
                    <h3>Read Preference</h3>
                    <pre style="width: 100%;"><code class="python">import pymongo​                                                 # Python
c = pymongo.MongoClient(host=["mongodb://pc1:27017", 
     "mongodb://pc3:27017", "mongodb://pc3:27017"], 
     read_preference=pymongo.read_preferences.ReadPreferency.SECONDARY​)​
db = c.test​
doc = db.personen.find_one({"name":"Franka"})​
print(doc)​​</code></pre>

<h4>Read Preference: Mit wem verbinden zum Lesen?</h4>
<ul style="font-size: 90%; margin-top: -5mm;">
    <li><b><code>PRIMARY</code></b> &Rightarrow; Strong Consistency</li>
    <li><b><code>PRIMARY_PREFERRED</code></b></li>
    <li><b><code>SECONDARY</code></b></li>
    <li><b><code>SECONDARY_PREFERRED</code></b></li>
    <li><b><code>NEAREST</code></b> (der Knoten mit kleinstem Ping)</li>
</ul>

<div class="poll fragment" style="bottom:-90px" data-fragment-index="4">
    <h1>Bei welchen Read Preferences haben wir Eventual Consistency?</h1>
            <ul>
                    <li>SECONDARY</li>
                    <li>SECONDARY, SECONDARY_PREFERRED</li>
                    <li>Alle bis auf PRIMARY und PRIMARY_PREFERRED</li>
                    <li data-poll="correct">Alle bis auf PRIMARY</li>
            </ul>
    <h2>https://fraage.de</h2>
</div>

<aside class="notes">Wenn sich Anwendungen mit MongoDB verbinden, gibt man alle Knoten mit an sowie eine Read-Preference. Der Treiber verbindet einen dann mit dem entsprechenden Knoten. <code>_PREFERRED</code> bedeutet, dass auch von Secondary bzw. Primary gelesen wird, sollte kein Primary bzw. Secondary verfügbar sein.</aside>
                </section>

                <section>
                    <h3>Asynchrone vs. synchrone Repl.</h3>
                    <h4 style="margin-bottom: -5mm;">Asynchrone Replikation: $w = 1$</h4>
                    <p class="small">Client schreibt auf Primary, bekommt das ACK, danach wird repliziert.
                        <br>&Rightarrow; Replikation ist eine separate Transaktion.</p>
                    </p>

                    <h4 style="margin-bottom: -5mm;">Synchrone Replikation: $w = N$</h4>
                    <p class="small">Client schreibt auf Primary, dann wird repliziert, dann bekommt er das ACK.
                <br>&Rightarrow; Replikation ist Teil der Transaktion.
                <br>&Rightarrow; Strong Consistency</p>

                    <h4 style="margin-bottom: -5mm;">Write-Concern: $0 \le w \le N$</h4>
                    <p class="small">Client bekommt ACK, wenn die Schreiboperation auf $w$ Knoten ausgeführt wurde.</p>

                    <aside class="notes">Bei synchroner Replikation muss eine Client-Anwendung warten, bis die Änderungen, die sie ausführt, auf allen Rechnern durchgeführt wurde. Das dauert oft zu lange, vor allem, wenn Slaves temporär offline gehen. Bei MongoDB wird daher standardmäßig asynchrone Replikation eingesetzt. Das heißt, der Primary gibt dem Client die Bestätitigung (ACK), dass die Änderungen ausgeführt wurden, sobald er dies abgeschlossen hat. Erst danach erfolgt die Weitergabe der Aktionen an die Secondaries. Kurzzeitig sind die Secondaries also in einem inkonsistenten und damit veralteten Zustand. ​</aside>
                </section>

                <section>
                    <h3>Write-Concern</h3>

                    <pre><code class="javascript">db.personen.insertOne( { name:"Rita" }, 
        { writeConcern: { w : "majority", wtimeout : 100 } } )</code></pre>

                    <pre><code class="python">import pymongo​                                        # Python
c = pymongo.MongoClient(host=["mongodb://pc1:27017"], w=3)​
db = c.test​
doc = db.personen.find_one({"name":"Franka"})​
print(doc)​
db.personen.insert_one({"name":"Timo"})​</code></pre>

<div class="poll fragment" style="bottom:-320px" data-fragment-index="4">
    <h1>Was ist der Nachteil von w=3 (bei 3 Knoten im Replika-Set)?</h1>
            <ul>
                 <li>Writes können verloren gehen</li>
                    <li>Kann zu Konflikten führen</li>
                    <li>Kann etwas länger dauern</li>
                    <li data-poll="correct">Kann auch mal seeehr viel länger dauern</li>
            </ul>
    <h2>https://fraage.de</h2>
</div>

                    <aside class="notes">Legt der Client ein Write-Concern fest, bekommt er sein ACK vom Primary erst, wenn seine Schreiboperation mindestens $w$ Rechner erreicht hat. Bei $w=1$ gibt es dass ACK, wenn der Primary das Schreiben lokal ausgeführt hat, $w=2$ wäre Primary plus irgendein Secondary. w=majority ist der Fall wenn mehr als die Hälfte der Rechner die Schreiboperation durchgeführt haben (bei 3 Knoten also 2). Sogar $w=0$ ist möglich. Dann bekommt der Client gar keine Bestätigung (höchstens mal eine Exception) vom Master. Er kann dann also gar nicht sicher sein, dass die Schreiboperation überhaupt ausgeführt wurde. Das Write-Concern kann für eine Operation (z. B. <code>insert</code>) oder eine Connection (also vom Client) festgelegt werden, aber auch für eine ganze Collection, sodass alle Clients standardmäßig ein gewissen Wert für $w$ haben. Der Wert kann auch global für ein komplettes ReplicaSet gesetzt werden. Der Standard ist $w=1$.​ Wichtig bei Replikation: Da in diesem Python-Beispiel ein Insert ausgeführt wird, muss der Knoten, mit dem sich hier verbunden wird, der Primary, also der Replication-Master sein.​</aside>
                </section>

                <section>
                    <h3>Strong Consistency</h3>
                    <p class="small"><img src="img/1/mongodb.png" class="noborder" style="margin-top:-5mm; margin-bottom:-5mm">: Strong Consistency, wenn $w=N$ oder<br><code style="margin-left: 12.5cm;">read_preference=PRIMARY</code><br>(weil Schreiboperationen immer nur auf dem Primary erfolgen)</p>
                    <p class="small">Im Allgemeinen: $r + w \gt N$<br>(wenn Schreiboperationen auf beliebigen Knoten erfolgen können)</p>
                    <ul class="small">
                        <li>$r$ - Anzahl Knoten, von denen gelesen wird (bei MongoDB immer 1)</li>
                        <li>$w$ - So viele Knoten müssen das Write bestätigen (Write Concern)</li>
                        <li>$N$ - Anzahl der Knoten im Replika-Set insgesamt</li>
                    </ul>
                </section>

                <section>
                    <h3>Strong Consistency: $r + w \gt N$</h3>
                    <p class="small">Beispiel: $r = 1, w = 3, N = 3$</p>
                    <div class="columns">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code><br><span class="fragment">&uparrow; lesen<br>(aktueller Wert)</span></p></div>
                    </div>
                    <aside class="notes">Hier wird ein Write-Concern von $w = 3$ verwendet. Es wird also beim Schreiben abgewartet, bis die Schreiboperation auf allen Knoten ausgeführt wurde. Danach ist es egal, von welchem Knoten man liest, man erhält aktuelle Daten.</aside>
                </section>

                <section>
                    <h3>Strong Consistency: $r + w \gt N$</h3>
                    <p class="small">Beispiel: $r = 3, w = 1, N = 3$</p>
                    <div class="columns">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen<br>(aktueller Wert)</span></span></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="3">preis:4€</code><br><code class="fragment" data-fragment-index="3">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen</span></span></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="3">preis:4€</code><br><code class="fragment" data-fragment-index="3">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen</span></span></p></div>
                    </div>
                    <aside class="notes">In diesem Beispiel wird nach dem Schreiben weitergemacht, wenn die Schreiboperation von einem Knoten bestätigt wurde ($w = 1$). Um nun Strong Consistency zu gewährleisten, muss von allen Knoten gelesen werden. Dann ist ja in jedem Falle auch derjenige dabei, auf dem das Schreiben bereits durchgeführt wurde. Anhand von Timestamps kann der Client dann ermitteln, welche Version eines Wertes die aktuellste ist. Bei Redis lässt sich dieses Verhalten so umsetzen. In MongoDB liest man immer nur von einem Knoten. Ist das der Primary, haben wir stets strong Consistency, da dort ja auch geschrieben wurde. Bei Redis darf überall geschrieben werden.</aside>
                </section>

                <section>
                    <h3>Strong Consistency: $r + w \gt N$</h3>
                    <p class="small">Beispiel: $r = 2, w = 2, N = 3$</p>
                    <div class="columns">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="3">preis:4€</code><br><code class="fragment" data-fragment-index="3">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen</span></span></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen<br>(aktueller Wert)</span></span></p></div>
                    </div>
                    <aside class="notes">Ist $r + w \gt N$, überlappen sich das Read-Set und das Write-Set. Beim Lesen ist also in jedem Falle mindestens ein Knoten dabei, auf dem die neusten Daten bereits geschrieben wurden.</aside>
                </section>

                <section>
                    <h3>Eventual Consistency: $r + w \le N$</h3>
                    <p class="small">Beispiel: $r = 1, w = 2, N = 3$</p>
                    <div class="columns">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="3">preis:4€</code><br><code class="fragment" data-fragment-index="3">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen<br>(veralteter Wert)</span></span></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                    </div>

                    <aside class="notes">Für alle Fälle, in denen $r + w \le N$ gilt, kann keine Konsistenz garantiert werden. Es kann sein, dass der Knoten, von dem man liest, noch nicht die Änderungen erhalten hat, die kürzlich geschrieben wurden.</aside>
                </section>

                <section>
                    <h2>ACID, BASE, CAP-Theorem</h2>
                    <h4>ACID</h4>
                    <ul>
                        <li><b>Atomarität</b><br>Alles-oder-Nichts-Prinzip​</li>
                        <li><b>Konsistenz</b><br>Transaktion hinterlässt konsistenten DB-Zustand​</li>
                        <li><b>Isolation</b><br>Parallel laufenden TAs beeinflussen sich nicht ​​</li>
                        <li><b>Dauerhaftigkeit</b><br>Committete Änderungen gehen nicht verloren​</li>
                    </ul>
                </section>

                <section>
                    <h2>ACID, BASE, CAP-Theorem</h2>
                    <h4>BASE</h4>
                    <ul style="width: 55cm;">
                        <li><b>Basically Available</b><br>DB akzeptiert und beantwortet Anfragen (meistens)​</li>
                        <li><b>Soft State</b><br>Es dauert, bis sich der DB-Zustand synchronisiert hat</li>
                        <li><b>Eventual Consistent</b><br>Irgendwann ist die DB wieder in konsistentem Zustand​​</li>
                    </ul>

                    <aside class="notes">Das Akronym BASE wird gerne vor allem in NoSQL-Datenbanken als Gegenstück für die strengen ACID-Eigenschaften verwendet, die vor allem meist in relationalen Datenbanken gefordert werden. Oft wird beispielsweise in Web-Anwendungen wie sozialen Netzwerken kein striktes ACID verlangt. Lockert man es auf und sagt, dass BASE ausreichend ist, kann dies zu enormen Performance-Vorteilen führen. Eventual Consistency wäre in ACID-DBs undenkbar. Soft State ebenso: Man liest zweimal das gleiche, niemand hat die Daten zwischenzeitlich geändert, trotzdem kommt zweimal was unterschiedliches raus.</aside>
                </section>

                <section>
                    <h2>ACID, BASE, CAP-Theorem</h2>
                    <h4>CAP-Theorem</h4>
                    <ul>
                        <li><b>Consistency</b> <br>DB liefert stets den aktuellen Wert</li>
                        <li><b>Availability</b> <br>DB liefert stets eine Antwort auf Anfragen</li>
                        <li><b>Partition Tolerance</b> <br>DB funktioniert auch, wenn mal etwas ausfällt</li>
                    </ul>
                    <p><b><em>Nur max. 2 dieser Eigenschaften lassen sich erreichen!</em></b></p>
                    <aside class="notes">Unter einer Netzwerkpartition versteht man, dass im Netzwerk ein Knoten einen anderen im Moment nicht erreichen kann, z. B. bei Netzwerkproblemen oder wenn der Knoten vorübergehend offline ist. Partition Tolerance bedeutet, dass das System in einem solchen Fall dennoch weiter funktioniert.</aside>
                </section>

                <section>
                    <h3>CAP-Theorem</h3>
                    <p class="small">In einem verteilten DBMS brauchen wir Partition Tolerance.<br>
                    Netzwerkpartitionen können nunmal auftreten.</p>

                    <div class="columns" style="margin-top:-3mm">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server red"></i></h1><p class="small" style="margin-top: -10mm;"><code>preis:4€</code></p></div>
                    </div>

                    <div class="fragment">
                    <h4 style="margin-top: -3mm; margin-bottom: -5mm;">CP: Consistency + Partition Tolerance</h4>
                    <p class="small">Warten, bis Knoten 3 sich wieder synchronisiert hat. &Rightarrow; keine Availability.</p>
                    </div>

                    <div class="fragment">
                    <h4 style="margin-top: -3mm; margin-bottom: -5mm;">AP: Availability + Partition Tolerance</h4>
                    <p class="small">Beim Lesen von Knoten 3 liest man veraltete Daten. &Rightarrow; keine Consistency.</p>
                    </div>

                    <aside class="notes">In MongoDB hat man die Wahl zwischen CP und AP über die Read Preference. Liest man vom Primary, hat man Konsistenz, liest man auch von Secondaries, hat man Availability. Standard ist also CP.</aside>
                </section>

                <section>
                    <h3>Binäre vs. Statement-basierte Replikation</h3>
                    <h4>Binäre Replikation</h4>
                    <p class="small">Master an Slaves nach jedem Write: "In Datei XYZ hat sich bei Offset 234 folgendes geändert: 0010101010010010001001010010010101001010001111101001010101"</p>
                    
                    <div class="fragment">
                    <h4>Statement-basierte Replikation &leftarrow; <img src="img/1/mongodb.png" class="noborder" style="margin-top:-5mm; margin-bottom:-5mm"></h4>
                    <ul class="small">
                        <li>Client schickt Write-Statement an Primary</li>
                        <li>Primary schreibt das Statement in die Collection <code>oplog.rs</code> (DB <code>local</code>)</li>
                        <li>Secondaries holen sich kontinuierlich Änderungen aus der Oplog<br>und führen sie aus</li>
                    </ul>
                    <p class="fragment small" style="width: 50cm; margin-top: 3mm;">(+) Verschiedene Storage-Engines auf Knoten möglich (z. B. In-Memory auf Primary)</p>
                    </div>
                    <aside class="notes">Binäre Replikation verursacht in der Regel weniger Datenverkehr über das Netzwerk. Dennoch verwendet MongoDB Statement-basierte Replikation. Hier werden statt konkreten binären Änderungen in der Datenbank lediglich die Statements an die Secondaries weitergeleitet.</aside>
                </section>

                <section>
                    <h3>Oplog</h3>
                    <p class="small">Beispiel: Ein neuer Kunde wird eingefügt.</p>
                    <pre style="width: 100%;"><code class="javascript">rs0:PRIMARY> db.kunden.insertOne( { name: "Peter" } )
WriteResult({ "nInserted" : 1 })</code></pre>

<div class="fragment">
                    <h4>Oplog (Capped Collection): <code>oplog.rs</code> in DB <code>local</code></h4>
                    <pre style="width: 100%;"><code class="javascript">rs0:PRIMARY> db.getSiblingDB("local").oplog.rs.find()
{
    "op" : "i",
    "ns" : "test.kunden",
    "ui" : UUID("ba043302-1592-4c7a-95b0-100a6c306457"),
    "o" : {
            "_id" : ObjectId("6197c6014f6105b1ed3555c9"),
            "name" : "Peter"
    },
    "ts" : Timestamp(1637336577, 1),
    // ...                    
}</code></pre>
</div>

<div class="poll fragment" style="bottom:-50px" data-fragment-index="4">
    <h1>Was war nochmal eine Capped Collection?</h1>
            <ul>
                 <li data-poll="correct">Collection mit Maximalgröße</li>
                    <li>Collection, in die nur geschrieben werden darf</li>
                    <li>Collection, aus der nur gelesen werden darf</li>
                    <li>Collection mit Untercollections</li>
            </ul>
    <h2>https://fraage.de</h2>
</div>

    <aside class="notes">Die Insert-Operation taucht in der Oplog auf, jedoch ist dort auch der Wert des <code>_id</code>-Feldes angegeben, damit diese auf allen Knoten einheitlich ist und damit die Operation im Oplog idempotent ist. Idempotent heißt, es würde keinen Unterschied machen, ob man die Operation einfach oder mehrmals ausführt.</aside>
                </section>

                <section>
                    <h3>Oplog</h3>
                    <p class="small">Beispiel: Zwei Kunden werden gelöscht.</p>
                    <pre style="width: 100%;"><code class="javascript">rs0:PRIMARY> db.kunden.deleteMany( { name: {$in:["Peter", "Ute"]} } )
{ "acknowledged" : true, "deletedCount" : 2 }</code></pre>

                    <pre style="width: 100%;"><code class="javascript" style="max-height: 25cm;">{
    "op" : "d", "ns" : "test.kunden",
    "o" : {
            "_id" : ObjectId("6197bd854f6105b1ed3555c8")
    },
    "ts" : Timestamp(1637336633, 1),
    // ...
}
{
    "op" : "d", "ns" : "test.kunden",
    "o" : {
            "_id" : ObjectId("6197c6014f6105b1ed3555c9")
    },
    "ts" : Timestamp(1637336633, 2),
    // ...
}</code></pre>
<aside class="notes">Jede Operation im Oplog ist idempotent. Das eine <code>deleteMany</code>-Statement wurde aufgesplittet in zwei einzelne Deletes konkreter Dokumente unter Angabe ihrer <code>_id</code>s.</aside>
                </section>

                <section>
                    <h3>Automatischer Failover</h3>
                    <div class="columns small">
                        <div style="font-size:102%"><h1><div style="position: relative; margin-top:3mm;">
                            <i style="position: absolute;" class="fas fa-server blue fragment fade-out" data-fragment-index="1"></i>
                            <i style="position: absolute;" class="fas fa-server red fragment" data-fragment-index="1" data-badge="Ausfall!" data-badge-position="tl"></i>
                        </div></h1><div style="margin-top: 2.9cm; padding-left: 28mm;">Primary</div></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary
                        <div class="fragment" data-fragment-index="2" style="font-size:smaller">"Wir brauchen einen<br>neuen Master!"</div></div></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary
                            <div class="fragment" data-fragment-index="3"  style="font-size:smaller">"Ja, wir brauchen<br>einen neuen Master!"</div></div></div>
                    </div>
                    <p></p>

                    <div class="fragment" data-fragment-index="4">
                    <h4>Wahl eines neuen Masters</h4>
                    <p style="margin-top: -1mm;" class="small"><b>Consenus</b>: &#8532;-Mehrheit an Stimmen erforderlich, um neuen Master zu bestimmen.​</p>
                    </div>

                    <div class="columns fragment small" data-fragment-index="5">
                        <div style="font-size:102%"><h1><div style="position: relative; margin-top:3mm;">
                            <i style="position: absolute;" class="fas fa-server blue fragment" data-fragment-index="6"></i>
                            <i style="position: absolute;" class="fas fa-server red fragment fade-out" data-badge="Ausfall!" data-badge-position="tl" data-fragment-index="6"></i>
                        </div></h1><div style="margin-top: 2.9cm; padding-left: 28mm;" class="fragment" data-fragment-index="6">Secondary</div></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Primary</div></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                    </div>

                    <aside class="notes">Wenn der Primary ausfällt, merken das die Secondaries daran, dass sie von ihm keinen Heartbeat mehr bekommen bzw. daran, dass Pings nicht beantwortet werden. Slaves können aber auch zu unrecht denken, dass der Master ausgefallen ist, z.B. wenn die Netzwerkverbindung zwischen Master und einem Slave unterbrochen wird. Deshalb besagt der Consensus-Algorithmus, dass mindestens zwei drittel der Rechner der Meinung sein müssen, dass sie einen neuen Master brauchen. Erst dann wird ein neuer Master bestimmt. Einer der Secondaries wird dann zum Primary, also zum neuen Master.​ Ist der ausgefallene Knoten wieder verfügbar, wird er selbst zum Secondary und bringt sich wieder mithilfe der Oplog des Masters auf den aktuellen Stand.
                        <br>&nbsp;
                    </aside>
                    
                </section>

                <section>
                    <h3>Wer wird Primary?</h3>
                    <h4>Priorities</h4>
                    <p class="small" style="margin-top: -3mm;">Höhere Priority &Rightarrow; höhere Wahrscheinlichkeit zum Master gewählt zu werden.</p>
                    <pre><code class="javascript">cfg = rs.conf()
cfg.members[0].priority = 0.5
cfg.members[1].priority = 2
cfg.members[2].priority = 2
rs.reconfig(cfg)</code></pre>

<div class="fragment">
    <h4><code>rs.stepDown()</code></h4>
    <p class="small" style="margin-top: -3mm;"  >Damit wird der Primary nun zum Secondary.</p>
    <pre><code class="plaintext">rs0:PRIMARY> rs.stepDown()
rs0:SECONDARY></code></pre>
</div>
                </section>

                <section>
                    <h3>Arbiter</h3>
                    <p class="small">Ein Arbiter ist ein Mitglied im Replika-Set, das keine Daten speichert.<br>Der Arbiter nimmt aber an Abstimmungen teil.</p>
                    <div class="columns" style="margin-top: -3mm; margin-bottom: -3mm;">
                        <div><h1><i class="fas fa-server green"></i></h1><p class="small" style="margin-top: -10mm;"></p></div>
                        <div><h1><i class="fas fa-server green"></i></h1><p class="small" style="margin-top: -10mm;"></p></div>
                        <div><h1><i class="fas fa-server yellow"></i></h1><p class="small" style="margin-top: -10mm; text-align: center;">Arbiter</p></div>
                    </div>
                    <pre><code class="javascript">> rs.initiate( {
    _id : "rs0",
    members: [
        { _id: 0, host: "localhost:27011" },
        { _id: 1, host: "localhost:27012" },
        { _id: 2, host: "localhost:27013", arbiterOnly: true }
    ]
})</code></pre>
<aside class="notes">Um auch bei Replikationsfaktor 2 eine 2/3-Mehrheit zu bekommen, gibt es den Ansatz einen dritten Knoten den Replika-Set hinzuzufügen, der jedoch nur Arbiter ist. Dazu reicht in der Praxis ein Mailserver, Webserver, o. ä., der ohnehin läuft.</aside>
                </section>

                <section>
                    <h3>Delayed Members</h3>
                    <p class="small">Ein Secondary, der einen älteren Zustand der DB speichert.<br>
                    &Rightarrow; Ein rollendes Backup. </p>
                    <pre><code class="javascript">> rs.initiate( {
    _id : "rs0",
    members: [
        { _id: 0, host: "localhost:27011" },
        { _id: 1, host: "localhost:27012" },
        { _id: 2, host: "localhost:27013", 
          priority: 0, secondaryDelaySecs: 3600  }
    ]
})</code></pre>
<p class="small">(+) Nach Anwenderfehler hat man eine Stunde Zeit, die Daten wiederherzustellen.</p>

<aside class="notes">Delayed Replica-Set-Members müssen Priorität 0 haben, damit sie auf keinen Fall zum Primary gewählt werden. Sie holen sich aus der Oplog diejenigen Operationen bis zum Zeitpunkt <code>jetzt - secondaryDelaySecs</code>. In der hier gezeigten Konfiguration hat man also bei dem einen Knoten die Möglichkeit, stets auf den Zustand der Datenbank zuzugreifen, wie er vor einer Stunde war.</aside>
                </section>

                <section>
                    <h3>Partitionierung / Sharding</h3>
                    <p class="small" style="margin-top: -5mm;">Daten werden (gleichmäßig) verteilt auf den Knoten im Cluster gespeichert.</p>
                    <h4>Bereichspartitionierung (Range-Partitioning)</h4>
                    <div class="columns" style="margin-top: -3mm; margin-bottom: -3mm;">
                        <div><h1><i class="fas fa-server yellow"></i></h1><p class="small" style="margin-top: -10mm;">_id &in; [-&infin;, 999]</p></div>
                        <div><h1><i class="fas fa-server green"></i></h1><p class="small" style="margin-top: -10mm;">&nbsp;[1000, 1999]</p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2000, &infin;]</p></div>
                    </div>
                    <p class="small">(+) unterstützt Gleichheits- (=) und Bereichsanfragen (&lt;, &ge;, ...) auf dem Shard-Key</p>
                    <p class="small">(-) Bildung von Hotspots möglich</p>
                    
                    <div class="poll fragment" style="bottom:-165px" data-fragment-index="4">
                        <h1>Sharding ist ein Ansatz für ...?</h1>
                                <ul>
                                     <li data-poll="correct">Horizontale Skalierung</li>
                                        <li>Vertikale Skalierung</li>
                                </ul>
                        <h2>https://fraage.de</h2>
                    </div>

                    <aside class="notes">Bei der Partitionierung werden anders als bei der Replikation Daten nicht redundant gespeichert. Stattdessen wird der Datenbestand in Teile aufgeteilt und diese über die Cluster-Knoten verteilt gespeichert. In der dargestellten Grafik speichert jeder Knoten ein Drittel der Daten, Gleichverteilung vorausgesetzt. Ein Hotspot ist ein Wert oder ein Intervall von Werten, auf welches viel häufiger zugegriffen wird, als auf andere. Beispiel: Wenn Daten nach einem Zeitstempel partitioniert werden, greifen die meisten Anfragen auf aktuelle Datensätze mit hohen Timestamp-Werten zu als auf historische Daten.</aside>
                </section>

                <section>
                    <h3>Partitionierung / Sharding</h3>
                    <p class="small" style="margin-top: -5mm;">Daten werden (gleichmäßig) verteilt auf den Knoten im Cluster gespeichert.</p>
                    <h4>Hash-Partitionierung / Consistent Hashing</h4>
                    <p class="small">$h(k) = \dots ~ mod ~ 2^{32}$</p>
                    <div class="columns" style="margin-top: -3mm; margin-bottom: -3mm;">
                        <div style="margin-left: -6cm;"><h1><i class="fas fa-server yellow"></i></h1><p class="small" style="margin-top: -10mm;">h(MAC_ADDR) = 858&thinsp;993&thinsp;459</p></div>
                        <div style="margin-left: -11cm;"><h1><i class="fas fa-server green"></i></h1><p class="small" style="margin-top: -10mm;">&nbsp;2&thinsp;576&thinsp;980&thinsp;378</p></div>
                        <div style="margin-left: -11cm;"><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;">&nbsp;3&thinsp;435&thinsp;973&thinsp;827</p></div>
                    </div>
                
                <p class="small" style="width: 108%; font-size: 68%;">Datensatz mit Key $k$ auf dem Knoten speichern, dessen Hash am nächsten an $h(k)$ ist.</p>

                <div class="poll fragment" style="bottom:-120px" data-fragment-index="4">
                    <h1>Sei h(K) = k*(123^45) mod 2^32. Auf welchem Knoten wird der Datensatz mit ID 29 gespeichert?</h1>
                            <ul>
                                    <li>auf dem grünen</li>
                                    <li>nirgendwo</li>
                                    <li data-poll="correct">auf dem gelben</li>
                                    <li>auf dem blauen</li>
                            </ul>
                    <h2>https://fraage.de</h2>
                </div>

                <aside class="notes">Ein primitiver Ansatz wäre, $h(k) = k ~ mod ~ N$ als Hash-Funktion zu wählen (N: Anzahl der Knoten im Cluster, hier: 3). Dies würde aber einen immensen Repartitionierungs-Aufwand verursachen, wenn ein Knoten dem Cluster hinzugefügt wird, weil dann die Hash-Funktion angepasst werden muss. Beim Consistent Hashing wird immer die gleiche Hash-Funktion verwendet, unabhängig von der Anzahl Cluster-Knoten. Mit der Hash-Funktion berechnet man den Knoten, auf welchem ein Datensatz gespeichert wird. Anders als bei der Bereichspartitionierung unterstützt Hash-Partitioning keine Bereichsanfragen (&lt;, &ge;, ...) auf dem Key.</aside>
                </section>	


                <section>
                    <h3>Sharding in MongoDB</h3>
                    <div class="small" style="margin-top: -30mm; position: absolute;">
                    <div class="sl-block" data-block-type="text" data-name="text-1108bc" data-block-id="4d26b5dac860b768a92b7c7cd9207aa3" style="height: auto; width: 171px; left: 166px; top: 417.25px;">
                        <div class="sl-block-content green" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; color:black; border-style: solid; border-width: 1px;">
                            <p style="text-align: center;"><strong>shard1</strong></p>
                    
                            <p style="text-align: center;">mongod<br>
                                mongod<br>
                                mongod</p>
                        </div>
                    </div>
                    <div class="sl-block" data-block-type="text" style="height: auto; width: 171px; left: 560.5px; top: 417.25px;" data-block-id="310a49d99a53b472f339fe77254ec419" data-name="text-f72f3c">
                        <div class="sl-block-content green" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; color:black; border-style: solid; border-width: 1px;">
                            <p style="text-align: center;"><strong>shard3</strong></p>
                    
                            <p style="text-align: center;">mongod<br>
                                mongod<br>
                                mongod</p>
                        </div>
                    </div>
                    <div class="sl-block" data-block-type="text" style="height: auto; width: 171px; left: 362px; top: 417.25px;" data-block-id="4aaaaaf28152888535f12d5cf0e30f5b" data-name="text-57c659">
                        <div class="sl-block-content green" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; color:black; border-style: solid; border-width: 1px;">
                            <p style="text-align: center;"><strong>shard2</strong></p>
                    
                            <p style="text-align: center;">mongod<br>
                                mongod<br>
                                mongod</p>
                        </div>
                    </div>
                    <div class="sl-block" data-block-type="text" style="height: auto; width: 279px; left: 308px; top: 251.25px;" data-block-id="708130f7350f41101b35da9b5ba11375" data-name="text-caa4f7">
                        <div class="sl-block-content orange" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 13; border-style: solid; border-width: 1px; color:black;">
                            <p style="text-align: center;"><strong>sharding server</strong></p>
                    
                            <p style="text-align: center;">mongos</p>
                        </div>
                    </div>
                    <div class="sl-block" data-block-type="text" style="height: auto; width: 171px; left: 709px; top: 145.25px;" data-block-id="ef728ff96b2ba39167def19c4d53b6f3" data-name="text-137082">
                        <div class="sl-block-content yellow" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 14; border-style: solid; border-width: 1px; color:black">
                            <p style="text-align: center;"><strong>config servers</strong></p>
                    
                            <p style="text-align: center;">mongod<br>
                                mongod<br>
                                mongod</p>
                        </div>
                    </div>
                    <div class="sl-block" data-block-type="text" data-name="text-0fcbe6" data-block-id="9c4b232363ff0491505e67c7dbdb4bba" style="height: auto; width: 283px; left: 308px; top: 116.75px;">
                        <div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 15;">
                            <p style="text-align: center;"><i class="fas fa-user blue"></i><br>
                                Client</p>
                        </div>
                    </div>
                    <div class="sl-block" data-block-type="line" data-name="line-7635fe" data-block-id="fd7114d2c049df3c6e2444021f46acaf" style="width: auto; height: auto; min-width: 0px; min-height: 0px; left: 240px; top: 350px;">
                        <div class="sl-block-content" data-line-x1="85" data-line-y1="0" data-line-x2="0" data-line-y2="53" data-line-color="#000000" data-line-start-type="none" data-line-end-type="line-arrow" style="z-index: 16;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="85" height="53" viewBox="0 0 85 53">
                                <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="85.5" y1="0.5" x2="3.6820950287781486" y2="51.51587015852657"></line>
                                <line class="line-element" stroke="#000000" stroke-width="5" x1="85.5" y1="0.5" x2="3.6820950287781486" y2="51.51587015852657"></line>
                                <path style="fill: rgba(0,0,0,0);" stroke="#000000" stroke-width="5" transform="translate(3.1820950287781486,51.01587015852657) rotate(238.055)" d="M 11.25 11.25 L 0 0 L -11.25 11.25"></path>
                            </svg></div>
                    </div>
                    <div class="sl-block" data-block-type="line" style="width: auto; height: auto; min-width: 0px; min-height: 0px; left: 560.5px; top: 350px;" data-block-id="032051c865d20039a7c4bd276c6570fc" data-name="line-49889b">
                        <div class="sl-block-content" data-line-x1="0" data-line-y1="0" data-line-x2="74.5" data-line-y2="53" data-line-color="#000000" data-line-start-type="none" data-line-end-type="line-arrow" style="z-index: 17;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="74.5" height="53" viewBox="0 0 74.5 53">
                                <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="0.5" y1="0.5" x2="71.94434806011854" y2="51.32618049914473"></line>
                                <line class="line-element" stroke="#000000" stroke-width="5" x1="0.5" y1="0.5" x2="71.94434806011854" y2="51.32618049914473"></line>
                                <path style="fill: rgba(0,0,0,0);" stroke="#000000" stroke-width="5" transform="translate(71.44434806011854,50.82618049914473) rotate(125.428)" d="M 11.25 11.25 L 0 0 L -11.25 11.25"></path>
                            </svg></div>
                    </div>
                    <div class="sl-block" data-block-type="line" style="width: auto; height: auto; min-width: 0px; min-height: 0px; left: 447.5px; top: 357.25px;" data-block-id="5f6653dc8dfea5abe44d96ff0ee7d960" data-name="line-4da322">
                        <div class="sl-block-content" data-line-x1="0" data-line-y1="0" data-line-x2="0" data-line-y2="45.75" data-line-color="#000000" data-line-start-type="none" data-line-end-type="line-arrow" style="z-index: 18;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="45.75" viewBox="0 0 1 45.75">
                                <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="0.5" y1="0.5" x2="0.5" y2="42.5"></line>
                                <line class="line-element" stroke="#000000" stroke-width="5" x1="0.5" y1="0.5" x2="0.5" y2="42.5"></line>
                                <path style="fill: rgba(0,0,0,0);" stroke="#000000" stroke-width="5" transform="translate(0,42) rotate(180)" d="M 11.25 11.25 L 0 0 L -11.25 11.25"></path>
                            </svg></div>
                    </div>
                    <div class="sl-block" data-block-type="line" style="width: auto; height: auto; min-width: 0px; min-height: 0px; left: 597.75px; top: 241.75px;" data-block-id="53906a799ecb4c8f3111b67f577234a7" data-name="line-370422">
                        <div class="sl-block-content" data-line-x1="0" data-line-y1="62.25" data-line-x2="103" data-line-y2="0" data-line-color="#000000" data-line-start-type="none" data-line-end-type="line-arrow" style="z-index: 19;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="103" height="62.25" viewBox="0 0 103 62.25">
                                <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="0.5" y1="62.75" x2="100.29060407132171" y2="2.4396591899050812"></line>
                                <line class="line-element" stroke="#000000" stroke-width="5" x1="0.5" y1="62.75" x2="100.29060407132171" y2="2.4396591899050812"></line>
                                <path style="fill: rgba(0,0,0,0);" stroke="#000000" stroke-width="5" transform="translate(99.79060407132171,1.9396591899050812) rotate(58.853)" d="M 11.25 11.25 L 0 0 L -11.25 11.25"></path>
                            </svg></div>
                    </div>
                    <div class="sl-block" data-block-type="line" style="width: auto; height: auto; min-width: 0px; min-height: 0px; left: 447.5px; top: 195.75px;" data-block-id="deabc136e4ade02ff1706d5c4a41c0a1" data-name="line-790f65">
                        <div class="sl-block-content" data-line-x1="0" data-line-y1="0" data-line-x2="0" data-line-y2="45.75" data-line-color="#000000" data-line-start-type="none" data-line-end-type="line-arrow" style="z-index: 20;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="45.75" viewBox="0 0 1 45.75">
                                <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="0.5" y1="0.5" x2="0.5" y2="42.5"></line>
                                <line class="line-element" stroke="#000000" stroke-width="5" x1="0.5" y1="0.5" x2="0.5" y2="42.5"></line>
                                <path style="fill: rgba(0,0,0,0);" stroke="#000000" stroke-width="5" transform="translate(0,42) rotate(180)" d="M 11.25 11.25 L 0 0 L -11.25 11.25"></path>
                            </svg></div>
                    </div>
                    <div class="sl-block" data-block-type="line" style="width: auto; height: auto; min-width: 0px; min-height: 0px; left: 447.5px; top: 357.25px;" data-block-id="495a57c7f0824725b587d3677b339826" data-name="line-beb5dc">
                        <div class="sl-block-content" data-line-x1="0" data-line-y1="0" data-line-x2="0" data-line-y2="45.75" data-line-color="#000000" data-line-start-type="none" data-line-end-type="line-arrow" style="z-index: 21;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="45.75" viewBox="0 0 1 45.75">
                                <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="0.5" y1="0.5" x2="0.5" y2="42.5"></line>
                                <line class="line-element" stroke="#000000" stroke-width="5" x1="0.5" y1="0.5" x2="0.5" y2="42.5"></line>
                                <path style="fill: rgba(0,0,0,0);" stroke="#000000" stroke-width="5" transform="translate(0,42) rotate(180)" d="M 11.25 11.25 L 0 0 L -11.25 11.25"></path>
                            </svg></div>
                    </div>
                    </div>

                    <aside class="notes"><code>mongos</code> ist ein Prozess, der sich um das Sharding kümmert. Er speichert Informationen, zu welcher Collection welche Dokumente auf welchem "shard" gespeichert sind, auf den Config-Servern. Ein Client (und auch die MongoDB Shell) kann sich zu einem mongos-Prozess genau so verbinden und damit arbeiten wie mit einem <code>mongod</code>-Prozess.​ Sharding wird in Kombination mit Replikation eingesetzt.</aside>
                </section>

                <section>
                    <h3>Sharding in MongoDB</h3>
                    <h4><code style="background-color: #ffaa63;">mongos</code> - MongoDB Sharding-Server</h4>
                    <p class="small" style="width: 105%; margin-top: -3mm;">Nimmt Client-Anfragen entgegen,<br>kommuniziert mit den Shard- und Config-Servern.</p>

                    <h4><code style="background-color: rgba(66, 169, 170, 0.99);">mongod</code> - Shard-Server</h4>
                    <p class="small" style="width: 105%; margin-top: -3mm;">Bilden jeweils einzelne Replika-Sets,<br>speichern die Daten.</p>

                    <h4><code style="background-color: #ffcb63">mongod</code> - Config-Server</h4>
                    <p class="small" style="width: 105%; margin-top: -3mm;">Bilden ebenfalls ein Replika-Set,<br>speichern Konfiguration und Metadaten (wo ist was gespeichert?).</p>
                
                    <aside class="notes">Die Daten in einem Sharded Cluster werden auf sogenannten Shards gespeichert. Dies sind ganz normale Replika-Sets aus <code>mongod</code>-Instanzen. Die Config-Server sind ebenfalls <code>mongod</code>-Instanzen, die ein eigenes Replika-Set bilden. <code>mongos</code> holt sich die Infos, was wo gespeichert ist, von den Config-Servern, um dann schließlich auf die Daten zuzugreifen, die der Client anfordert. Man kann beliebig viele <code>mongos</code> starten, die sich mit denselben Config-Servern verbinden. Sie sind also kein Single-Point-of-Failure.</aside>
                </section>

                <section>
                    <h3>Sharding einrichten (1/3)</h3>
                    <p class="small"><b>1. <code>mongod</code> auf den Shard- und Config-Servern starten</b> (hier: 12x auf localhost)</p>
                    <pre style="width: 100%;"><code class="bash">mongod --replSet "s1" --shardsvr --port 27011 --dbpath /data/data11
mongod --replSet "s1" --shardsvr --port 27012 --dbpath /data/data12
mongod --replSet "s1" --shardsvr --port 27013 --dbpath /data/data13
mongod --replSet "s2" --shardsvr --port 27021 --dbpath /data/data21
mongod --replSet "s2" --shardsvr --port 27022 --dbpath /data/data22
mongod --replSet "s2" --shardsvr --port 27023 --dbpath /data/data23
mongod --replSet "s3" --shardsvr --port 27031 --dbpath /data/data31
mongod --replSet "s3" --shardsvr --port 27032 --dbpath /data/data32
mongod --replSet "s3" --shardsvr --port 27033 --dbpath /data/data33
mongod --replSet "c" --configsvr --port 57041 --dbpath /data/config1
mongod --replSet "c" --configsvr --port 57042 --dbpath /data/config2
mongod --replSet "c" --configsvr --port 57043 --dbpath /data/config3</code></pre>

<aside class="notes">Das auf den folgenden Folien gezeigte Beispiel soll verdeutlichen, welche Prozesse bei einem Sharded Cluster laufen. In der Praxis werden die hier gezeigten Kommandos automatisiert ausgeführt, über Config-Dateien konfiguriert und oft auch administrative Tools eingesetzt.<br>
Wir starten hier 12 <code>mongod</code>-Prozesse: Pro Shard bilden jeweils 3 Instanzen ein Replika-Set, also ingesamt 9 Shard Server. Dazu kommen drei Config-Server, die ebenfalls ein Replika-Set bilden.</aside>

</section>
<section>
    <h3>Sharding einrichten (2/3)</h3>
                    <p class="small"><b>2. Pro Replika-Set Replikation initialisieren:</b></p>
                    <pre><code class="javascript">> rs.initiate( {
    _id : "s1",
    members: [
        { _id: 0, host: "localhost:27011" },
        { _id: 1, host: "localhost:27012" },
        { _id: 2, host: "localhost:27013" }
    ]
}) /* Das gleiche nochmal mit Replika-Set s2 und s3 */</code></pre>

<pre><code class="javascript">> rs.initiate( {
    _id : "c",
    configsvr: true,
    members: [
        { _id: 0, host: "localhost:57041" },
        { _id: 1, host: "localhost:57042" },
        { _id: 2, host: "localhost:57043" }
    ]
})</code></pre>
<aside class="notes">Die hier gezeigte Initialisierung der Replika-Sets muss für jeden der Shards erfolgen, sowie für die Config-Server. Dazu muss man sich mit jeweils einem beliebigen Knoten des Sets mit der Mongo Shell verbinden. Bei den Config-Servern wird <code>configsvr: true</code> angegeben.</aside>
                </section>

                <section>
                    <h3>Sharding einrichten (3/3)</h3>
                    <p class="small"><b>3. <code>mongos</code> starten (auf Standardport 27017):</b></p>
                    <pre style="width: 100%;"><code class="bash">mongos --configdb c/localhost:57041,localhost:57042,localhost:57043</code></pre>

                    <p class="small"><b>4. Sharding einrichten:</b></p>
                    <pre style="width: 100%;"><code class="javascript">mongos> sh.addShard("s1/localhost:27011")
mongos> sh.addShard("s2/localhost:27021")
mongos> sh.addShard("s3/localhost:27031")</code></pre>    

                    <aside class="notes"><code>mongos</code> läuft auf dem MongoDB-Standardport 27017, das heißt man kann sich nach dem Start wie gewohnt damit verbinden, z. B. mit der Mongo Shell, Compass oder einer anderen Anwendung. Um das Sharding einzurichten, verbindet man sich mit dem <code>mongos</code>-Server und fügt je Shard einen beliebigen Knoten mittels <code>sh.addShard</code> hinzu. Die übrigen Knoten der jeweiligen Replika-Sets holt sich MongoDB aus den entsprechenden Replika-Set-Konfigurationen. Die Einrichtung der Shards muss nur einmal gemacht werden, danach liegt die entsprechende Konfiguration auf den Config-Servern gespeichert.</aside>

                </section>

                <section>
                    <h3><code>sh.status()</code></h3>
                    <pre><code class="javascript" style="max-height: 30cm;">mongos> sh.status()
--- Sharding Status --- 
...
shards:
        {  "_id" : "s1",  "host" : "s1/localhost:27011,localhost:27012,localhost:27013",  "state" : 1,  "topologyTime" : Timestamp(1637397183, 2) }
        {  "_id" : "s2",  "host" : "s2/localhost:27021,localhost:27022,localhost:27023",  "state" : 1,  "topologyTime" : Timestamp(1637397237, 1) }
        {  "_id" : "s3",  "host" : "s3/localhost:27031,localhost:27032,localhost:27033",  "state" : 1,  "topologyTime" : Timestamp(1637397248, 1) }
...
databases:
        {  "_id" : "config",  "primary" : "config",  "partitioned" : true }
                config.system.sessions
                        shard key: { "_id" : 1 }
                        unique: false
                        balancing: true
                        chunks:</code></pre>

                        <aside class="notes"><code>sh.status</code> zeigt, dass wir drei Shards haben und aus welchen Rechnern diese bestehen. Unter <code>databases</code> stehen diejenigen Datenbanken, in denen es geshardete Collections gibt (siehe nächste Folie). Standardmäßig ist nämlich eine Collection nicht geshardet. Alle Dokumente werden dann auf einem "primary" Shard gespeichert.</code></aside>
                </section>

                <section>
                    <h3>Eine Collection sharden</h3>
                    <p class="small">Voraussetzung: Index auf dem Shard-Key</p>
                    <pre style="width: 100%;"><code class="javascript">mongos> db.produkte.createIndex({bezeichnung:1})​</code></pre>
                    
                    <pre class="fragment" style="width: 100%;"><code class="javascript">mongos> sh.enableSharding("test")
mongos> sh.shardCollection("test.produkte", {bezeichnung:1})</code></pre>
                        
                    <pre class="fragment" style="width: 100%;"><code class="javascript">mongos> sh.status()
...
databases:
{  "_id" : "test",  "partitioned" : true,  "primary" : "s1" }​
    test.produkte
            shard key: { "bezeichnung" : 1 }​
            chunks:​
                s1    2
                s3    1​
                s2    1​
{ "bezeichnung" : { "$minKey" : 1 } } -->> { "bezeichnung" : "Cello" } on : s2​
{ "bezeichnung" : "Cello" } -->> { "bezeichnung" : "Klavier" } on : s3
{ "bezeichnung" : "Klavier" } -->> { "bezeichnung" : "Ukulele" } on : s1
{ "bezeichnung" : "Ukulele" } -->> { "bezeichnung" : { "$maxKey" : 1 } } on : s1</code></pre>
                            
    <aside class="notes"><code>sh.status</code> zeigt nun, wo welche Dokumente gespeichert werden.</aside>
                                                    
                </section>

                <section>
                    <h3 style="font-size: 145%;">Gute Shard-Keys, schlechte Shard-Keys</h3>
                    <pre style="width: 100%;"><code class="json">{  ​
    "_id": ObjectId("564c7406b6b64b443b0f2d00"), // _id ist immer ok
    "type": "temperature",​ // hat wahrscheinlich wenig versch. Werte
    "longitude": "2.363471",  ​// sorgt für gute Gleichverteilung
    "latitude": "48.917536",​  //   "    "   "          "
    "city": "Nürnberg",​ // gut, wenn es viele Städte gibt
    "time": ISODate("2015-11-27T10:25:39Z"),​  // schlecht ("Hotspot")
    "value" : 5.8​,  // darauf sucht man wahrscheinlich nie
    "unit": "Celsius"​,  // zu geringe Kardinalität
    "visible_to": ["public","admin"]​  // verboten
}​</code></pre>
<aside class="notes">Der Shard-Key bestimmt, nach welchem Kriterium Dokumente auf den Shards verteilt werden. MongoDB bildet dann sogenannte Chunks, die einen Bereich von Werten beinhalten. Beispiel: Shard-Key "city". Der erste Chunk beinhaltet alles bis Köln, der zweite alles zwischen Köln und Regensburg, usw. Diese Chunks sind in etwa gleich groß, dafür sorgt ein Balancer. MongoDB verteilt die Chunks auf den einzelnen Shards. Ein guter Shard-Key hat keine zu geringe Kardinalität. Gibt es beispielsweise für "unit" nur die zwei Werte "Celsius" und "Fahrenheit", würden bei drei Shards auf einem gar nichts gespeichert werden. Und wenn fast alle Dokumente Celsius als Einheit haben, ist die Verteilung sehr ungerecht. Eine bessere Verteilung erreicht man mit Feldern, in denen es sehr viele verschiedene Werte gibt. Die _id ist als Shard-Key nie verkehrt. Aber eventuell eignen sich andere Felder besser. "city" könnte sinnvoll sein, wenn Anwendungen oft Anfragen mit einer Selektion auf diesem Feld stellen. "time" sollte als Shard-Key nicht verwendet werden, da die Zeitwerte monoton aufsteigen und somit sehr oft umpartitioniert werden muss.​</aside>
                </section>

                <section>
                    <h3>Hash-Partitionierung in MongoDB</h3>
                    <pre style="width: 100%;"><code class="javascript">mongos> db.produkte.createIndex({bezeichnung:"hashed"})​</code></pre>
                    
                    <pre style="width: 100%;"><code class="javascript">mongos> sh.shardCollection("test.produkte", {bezeichnung:"hashed"})</code></pre>

                    <p class="small">MongoDB bildet nun Chunks über die Ergebnisse der Hash-Funktion.</p>

                    <pre class="fragment" style="width: 100%;"><code class="javascript">mongos> sh.status()
...
databases:
{  "_id" : "test",  "partitioned" : true,  "primary" : "s1" }​
    test.produkte
            shard key: { "bezeichnung" : "hashed" }​
            chunks:​
                s1    2
                s3    1​
                s2    1​
{ "bezeichnung" : { "$minKey" : 1 } } 
-->> { "bezeichnung" : "5534023222112865483" } on : s2​
...</code></pre>

<aside class="notes">Suchen wir nach einem Produkt mit Bezeichnung x und kommt bei h(x) ein Wert kleiner als 5534023222112865483 raus, wissen wir, dass wir auf Shard s2 nachschauen müssen.</aside>
                </section>

                <section>
                    <h3>Zusammenfassung</h3>
                    <h4>Replikation</h4>
                    <ul class="small">
                        <li>Replika-Sets: Primary, Secondary</li>
                        <li><code>rs.secondaryOk()</code>, Read-Preference</li>
                        <li>BASE, CAP-Theorem</li>
                        <li>Write Concern, Strong Consistency, Eventual Consistency</li>
                        <li>Oplog</li>
                        <li>Automatischer Failover</li>
                        <li>Arbiter, Delayed Members</li>              
                    </ul>

                    <h4>Sharding</h4>
                    <ul class="small">
                        <li>Horizontale Skalierung</li>
                        <li>Range-Partitioning vs. Hash-Partitioning</li>
                        <li><code>mongos</code> Sharding-Server, Shard-Server, Config-Server</li>
                        <li>Shard-Keys, Chunks</li>
                    </ul>
                </section>
			</div>
		</div>

		<script src="reveal.js/dist/reveal.js"></script>
		<script src="reveal.js/plugin/markdown/markdown.js"></script>
		<script src="reveal.js/plugin/highlight/highlight.js"></script>
		<script src="reveal.js/plugin/zoom/zoom.js"></script>
		<script src="reveal.js/plugin/math/math.js"></script>
		<script src="reveal.js/plugin/notes/notes.js"></script>
		<script src="reveal.js/plugin/search/search.js"></script>
        <script src="lib/jquery.js"></script>
        <script src="lib/lodash.js"></script>
        <script src="lib/backbone.js"></script>
        <script src="lib/joint.min.js"></script>
				<script src="lib/deflate.js"></script>

		<script src="src/init_reveal.js"></script>

        <script>
        if(window.location.search.match( /print-pdf/gi )) {
                document.getElementById('header').style="display:none";
                document.getElementById('footer').style="display:none";
        }
        </script>


	</body>
</html>

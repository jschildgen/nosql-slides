<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>NoSQL-Datenbanken - Kapitel 4 - Replikation und Sharding</title>

		<link rel="stylesheet" href="reveal.js/dist/reset.css">
		<link rel="stylesheet" href="reveal.js/dist/reveal.css">

        <link rel="stylesheet" href="src/slides.css">
        <link rel="stylesheet" href="src/sql.css">

		<link rel="stylesheet" href="src/layout.css">
        <link rel="stylesheet" href="lib/joint.min.css" />
        <link rel="stylesheet" href="src/erd.css" />
        <link rel="stylesheet" href="src/poll.css" />

		<!-- Theme used for syntax highlighting of code -->
		<script>
			if(window.location.search.match( /print-pdf/gi )) {
				document.getElementsByTagName("head")[0].innerHTML += '<link rel="stylesheet" href="src/routeros.css">';
			} else {
				document.getElementsByTagName("head")[0].innerHTML += '<link rel="stylesheet" href="src/rainbow.css">';
			}
		</script>

        <!--<script defer src="lib/fontawesome.all.min.js"/>-->
        <link href="lib/fontawesome.all.min.css" rel="stylesheet">
        <style> .reveal i.fa { font-family:FontAwesome; font-style: normal; } </style>
	</head>
	<body>
		<div class="reveal">
            <div id="header"></div>
            <div id="footer"></div>
			<div class="slides">
                <section>
                    <h4 style="text-align:center"><b>Prof. Dr.-Ing. Johannes Schildgen</b><br>
                    <a href="mailto:johannes.schildgen@oth-regensburg.de">johannes.schildgen@oth-regensburg.de</a></h4>
                    <h2>NoSQL-Datenbanken</h2>
                    <h4 style="text-align:center">&nbsp;</h4>
                    <h3>Kapitel 4: Replikation und Sharding</h3>
                    <h4 style="text-align:center">&nbsp;<br>&nbsp;</h4>
                    <img src="img/ccby.png" height="60px" style="position: absolute; left:0px; border:0; bottom:-160px;">
                    <img src="img/oth.png" height="60px" style="position: absolute; right:0px; border:0; bottom:-160px; box-shadow:none">
                </section>

                <section>
                    <h3>Replikation</h3>
						<p class="small" style="margin-top: -5mm;">Kopien derselben Daten werden auf mehreren Rechnern gespeichert.</p>
                        <p class="small">&Rightarrow; Hochverfügbarkeit (Fehlertoleranz gegenüber Ausfall einzelner Server)</p>
                        <h4>In MongoDB: Replica-Sets (Master-Slave-Replikation)</h4>
                        <ul class="small">
                            <li>Replica Set besteht aus N Knoten, die dieselben Daten speichern
                            <br>+ optional 1 Arbiter-Knoten (speichert keine Daten)</li>
                            <li>Jeder Knoten ist eine <code>mongod</code>-Instanz</li>
                            <li>1 Primary-Knoten (Master), der Rest Secondary-Knoten (Slaves)</li>
                        </ul>
                            <!--
                                <ul>
                                    <li>Primary: Schreiboperationen passieren hier,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leseoperationen standardmäßig auch.</li>
                                    <li>Secondary: Hier darf auch gelesen werden.</li>
                                </ul>
                            </li>-->

                            <div class="small"><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Primary</div></div>
                            <div class="columns small">
                                <div><h2 style="margin-top: -10mm; margin-bottom: -5mm; margin-left: 4cm;" class="">&swarr;</h2><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                                <div><h2 style="margin-top: -10mm; margin-bottom: -5mm; margin-left: -6cm;" class="">&searr;</h2><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                            </div>

                </section>
                
                <section>
                    <h3>Replikation starten und einrichten</h3>
                    <p class="small"><b>1. <code>mongod</code> auf den Replikas starten</b> (hier: 3x auf localhost)</p>
                    <pre><code class="bash">mongod --replSet "rs0" --port 27011 --dbpath /data/data1
mongod --replSet "rs0" --port 27012 --dbpath /data/data2
mongod --replSet "rs0" --port 27013 --dbpath /data/data3</code></pre>

                    <p class="small"><b>2. Auf irgendeinem der Replika in der <code>mongo</code>-Shell Replikation initialisieren:</b></p>
                    <pre><code class="javascript">> rs.initiate( {
    _id : "rs0",
    members: [
        { _id: 0, host: "localhost:27011" },
        { _id: 1, host: "localhost:27012" },
        { _id: 2, host: "localhost:27013" }
    ]
})</code></pre>
<aside class="notes">In der Praxis laufen die einzelnen <code>mongod</code>-Instanzen natürlich jeweils auf verschiedenen Rechnern. Hier läuft zu Testzwecken alles auf localhost. Zum Initialisieren verbindet man sich mit einem beliebigen Replika (z. B. <code>mongo --port 27011</code>) und übergibt die Konfiguration des Replication-Sets. Wichtig ist, alle Replikas unter Angabe eines gemeinsamen Replika-Set-Namens (hier: <code>"rs0"</code>) zu starten und diesen Namen auch in der Konfiguration anzugeben.</aside>
                </section>

                <section>
                    <h3><code>rs.status()</code></h3>
                    <pre><code class="javascript" style="max-height: 30cm;">rs0:PRIMARY> rs.status()
{
    "set" : "rs0",
    "myState" : 1,     // 1: ich bin PRIMARY, 2: SECONDARY
    // ...
    "members" : [ 
    {    
        "_id" : 0,
        "name" : "localhost:27011",
        "state" : 1,
        "stateStr" : "PRIMARY",
        // ...
    }, 
    {
        "_id" : 1,
        "name" : "localhost:27012",
        "state" : 2,
        "stateStr" : "SECONDARY"
    }
    //...
</code></pre>

<aside class="notes">An dem <code>rs0:PRIMARY></code> bzw. <code>rs0:SECONDARY></code> in der Mongo-Shell erkennt man, ob man mit dem Primary oder einem Secondary verbunden ist. <code>rs.status()</code> zeigt die Konfiguration und den Zustand (sind Knoten offline? ...) der Replikation an.</aside>
                </section>

                <section>
                        <h3>Replikation in MongoDB</h3>
                        <div class="columns">
                            <div>
                                <h4 style="margin-bottom: -5mm;">Schreiboperationen</h4>
                                <p class="small">erfolgen auf dem Primary.</p>
                            </div>
                            <div>
                                <h4 style="margin-bottom: -5mm;">Leseoperationen</h4>
                                <p class="small">erfolgen standardmäßig auf dem Primary,
                                    <br>sind aber auch auf Secondaries möglich.
                                </p>
                            </div>
                        </div>

                        <pre style="width: 8cm; position: absolute; left: 2cm;" class="fragment"><code class="javascript">db.foo.insertOne(...)</code></pre>

                        <div class="small"><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Primary</div></div>
                        <div class="columns small">
                            <div><h2 style="margin-top: -10mm; margin-bottom: -5mm; margin-left: 4cm;" class="fragment">&swarr;</h2><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                            <div><h2 style="margin-top: -10mm; margin-bottom: -5mm; margin-left: -6cm;" class="fragment">&searr;</h2><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                        </div>
                        <aside class="notes">Bei einer Master-Master- (oder Multi-Master-)Replikation dürfen mehrere Masterknoten existieren, auf die jeweils geschrieben werden darf und die sich gegenseitig synchronisieren. Da dadurch Inkonsistenzen und Konflikte entstehen können (Welches Write gewinnt?), ist ein gängiger Ansatz die Master-Slave-Replikation, so auch in MongoDB. In MongoDB wird der Master (PRIMARY) automatisch gewählt.</aside>
                </section>

                <section>
                    <h3><code>rs.secondaryOk()</code></h3>
                    <p class="small">Leseoperationen sind auf Secondaries nur mit slaveOk möglich:</p>
                    <pre><code class="javascript">rs0:SECONDARY> db.kunden.count()</code></pre>
                    <p class="small"><i class="red">"errmsg" : "not master and slaveOk=false"</i></p>
                    <div class="fragment">
                    <h4>rs.secondaryOk()</h4>
                    <p class="small">Keine Garantie für Strong Consistency.<br>Lesen noch nicht synchronisierter Daten möglich.</p>
                    <pre><code class="plaintext">rs0:SECONDARY> rs.secondaryOk()
rs0:SECONDARY> db.kunden.count()
3</code></pre>
</div>
<aside class="notes">Mit <code>db.secondaryOk()</code> gibt man das Einverständnis, möglicherweise veraltete Daten zu lesen. Es könnte ja sein, dass Dokumente eingefügt, geändert oder gelöscht wurden, diese Änderung aber noch nicht auf den Secondary, mit dem man gerade verbunden ist, synchronisiert wurde, z. B. wegen Netzwerkverzögerungen.</aside>
                </section>

               

                <section>
                    <h3>Strong vs. Eventual Consistency</h3>
                    <p class="small">ACID fordert Strong Consistency!</p>
                    <h4>Strong Consistency</h4>
                    <pre><code class="javascript">rs0:PRIMARY> db.kunden.count()
4   // das ist stets der tatsächliche aktuelle Wert!</code></pre>

<div class="fragment">
<h4>Eventual Consistency (eventual &wedgeq; schließlich)</h4>
                    <pre><code class="plaintext">rs0:SECONDARY> rs.secondaryOk()
rs0:SECONDARY> db.kunden.count()
3
rs0:SECONDARY> db.kunden.count()
3
rs0:SECONDARY> db.kunden.count()
4</code></pre></div>
<aside class="notes">Eine Möglichkeit, strong Consistency in MongoDB zu erreichen, also in jedem Fall aktuelle Daten zu lesen, ist das Lesen vom Primary. Eine andere Möglichkeit ist mittels eines Write-Concerns möglich (siehe übernächste Folie).</aside>
                </section>

                <section>
                    <h3>Read Preference</h3>
                    <pre style="width: 100%;"><code class="python">import pymongo​                                                 # Python
c = pymongo.MongoClient(host=["mongodb://pc1:27017", 
     "mongodb://pc3:27017", "mongodb://pc3:27017"], 
     read_preference=pymongo.read_preferences.ReadPreferency.SECONDARY​)​
db = c.test​
doc = db.personen.find_one({"name":"Franka"})​
print(doc)​​</code></pre>

<h4>Read Preference: Mit wem verbinden zum Lesen?</h4>
<ul style="font-size: 90%; margin-top: -5mm;">
    <li><b><code>PRIMARY</code></b> &Rightarrow; Strong Consistency</li>
    <li><b><code>PRIMARY_PREFERRED</code></b></li>
    <li><b><code>SECONDARY</code></b></li>
    <li><b><code>SECONDARY_PREFERRED</code></b></li>
    <li><b><code>NEAREST</code></b> (der Knoten mit kleinstem Ping)</li>
</ul>
<aside class="notes">Wenn sich Anwendungen mit MongoDB verbinden, gibt man alle Knoten mit an sowie eine Read-Preference. Der Treiber verbindet einen dann mit dem entsprechenden Knoten. <code>_PREFERRED</code> bedeutet, dass auch von Secondary bzw. Primary gelesen wird, sollte kein Primary bzw. Secondary verfügbar sein.</aside>
                </section>

                <section>
                    <h3>Asynchrone vs. synchrone Repl.</h3>
                    <h4 style="margin-bottom: -5mm;">Asynchrone Replikation: $w = 1$</h4>
                    <p class="small">Client schreibt auf Primary, bekommt das ACK, danach wird repliziert.
                        <br>&Rightarrow; Replikation ist eine separate Transaktion.</p>
                    </p>

                    <h4 style="margin-bottom: -5mm;">Synchrone Replikation: $w = N$</h4>
                    <p class="small">Client schreibt auf Primary, dann wird repliziert, dann bekommt er das ACK.
                <br>&Rightarrow; Replikation ist Teil der Transaktion.
                <br>&Rightarrow; Strong Consistency</p>

                    <h4 style="margin-bottom: -5mm;">Write-Concern: $0 \le w \le N$</h4>
                    <p class="small">Client bekommt ACK, wenn die Schreiboperation auf $w$ Knoten ausgeführt wurde.</p>

                    <aside class="notes">Bei synchroner Replikation muss eine Client-Anwendung warten, bis die Änderungen, die sie ausführt, auf allen Rechnern durchgeführt wurde. Das dauert oft zu lange, vor allem, wenn Slaves temporär offline gehen. Bei MongoDB wird daher standardmäßig asynchrone Replikation eingesetzt. Das heißt, der Primary gibt dem Client die Bestätitigung (ACK), dass die Änderungen ausgeführt wurden, sobald er dies abgeschlossen hat. Erst danach erfolgt die Weitergabe der Aktionen an die Secondaries. Kurzzeitig sind die Secondaries also in einem inkonsistenten und damit veralteten Zustand. ​</aside>
                </section>

                <section>
                    <h3>Write-Concern</h3>

                    <pre><code class="javascript">db.personen.insertOne( { name:"Rita" }, 
        { writeConcern: { w : "majority", wtimeout : 100 } } )</code></pre>

                    <pre><code class="python">import pymongo​                                        # Python
c = pymongo.MongoClient(host=["mongodb://pc1:27017"], w=3)​
db = c.test​
doc = db.personen.find_one({"name":"Franka"})​
print(doc)​
db.personen.insert_one({"name":"Timo"})​</code></pre>

                    <aside class="notes">Legt der Client ein Write-Concern fest, bekommt er sein ACK vom Primary erst, wenn seine Schreiboperation mindestens $w$ Rechner erreicht hat. Bei $w=1$ gibt es dass ACK, wenn der Primary das Schreiben lokal ausgeführt hat, $w=2$ wäre Primary plus irgendein Secondary. w=majority ist der Fall wenn mehr als die Hälfte der Rechner die Schreiboperation durchgeführt haben (bei 3 Knoten also 2). Sogar $w=0$ ist möglich. Dann bekommt der Client gar keine Bestätigung (höchstens mal eine Exception) vom Master. Er kann dann also gar nicht sicher sein, dass die Schreiboperation überhaupt ausgeführt wurde. Das Write-Concern kann für eine Operation (z. B. <code>insert</code>) oder eine Connection (also vom Client) festgelegt werden, aber auch für eine ganze Collection, sodass alle Clients standardmäßig ein gewissen Wert für $w$ haben. Der Wert kann auch global für ein komplettes ReplicaSet gesetzt werden. Der Standard ist $w=1$.​ Wichtig bei Replikation: Da in diesem Python-Beispiel ein Insert ausgeführt wird, muss der Knoten, mit dem sich hier verbunden wird, der Primary, also der Replication-Master sein.​</aside>
                </section>

                <section>
                    <h3>Strong Consistency</h3>
                    <p class="small"><img src="img/1/mongodb.png" class="noborder" style="margin-top:-5mm; margin-bottom:-5mm">: Strong Consistency, wenn $w=N$ oder<br><code style="margin-left: 12.5cm;">read_preference=PRIMARY</code><br>(weil Schreiboperationen immer nur auf dem Primary erfolgen)</p>
                    <p class="small">Im Allgemeinen: $r + w \gt N$<br>(wenn Schreiboperationen auf beliebigen Knoten erfolgen können)</p>
                    <ul class="small">
                        <li>$r$ - Anzahl Knoten, von denen gelesen wird (bei MongoDB immer 1)</li>
                        <li>$w$ - So viele Knoten müssen das Write bestätigen (Write Concern)</li>
                        <li>$N$ - Anzahl der Knoten im Replika-Set insgesamt</li>
                    </ul>
                </section>

                <section>
                    <h3>Strong Consistency: $r + w \gt N$</h3>
                    <p class="small">Beispiel: $r = 1, w = 3, N = 3$</p>
                    <div class="columns">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code><br><span class="fragment">&uparrow; lesen<br>(aktueller Wert)</span></p></div>
                    </div>
                    <aside class="notes">Hier wird ein Write-Concern von $w = 3$ verwendet. Es wird also beim Schreiben abgewartet, bis die Schreiboperation auf allen Knoten ausgeführt wurde. Danach ist es egal, von welchem Knoten man liest, man erhält aktuelle Daten.</aside>
                </section>

                <section>
                    <h3>Strong Consistency: $r + w \gt N$</h3>
                    <p class="small">Beispiel: $r = 3, w = 1, N = 3$</p>
                    <div class="columns">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen<br>(aktueller Wert)</span></span></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="3">preis:4€</code><br><code class="fragment" data-fragment-index="3">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen</span></span></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="3">preis:4€</code><br><code class="fragment" data-fragment-index="3">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen</span></span></p></div>
                    </div>
                    <aside class="notes">In diesem Beispiel wird nach dem Schreiben weitergemacht, wenn die Schreiboperation von einem Knoten bestätigt wurde ($w = 1$). Um nun Strong Consistency zu gewährleisten, muss von allen Knoten gelesen werden. Dann ist ja in jedem Falle auch derjenige dabei, auf dem das Schreiben bereits durchgeführt wurde. Anhand von Timestamps kann der Client dann ermitteln, welche Version eines Wertes die aktuellste ist. Bei Redis lässt sich dieses Verhalten so umsetzen. In MongoDB liest man immer nur von einem Knoten. Ist das der Primary, haben wir stets strong Consistency, da dort ja auch geschrieben wurde. Bei Redis darf überall geschrieben werden.</aside>
                </section>

                <section>
                    <h3>Strong Consistency: $r + w \gt N$</h3>
                    <p class="small">Beispiel: $r = 2, w = 2, N = 3$</p>
                    <div class="columns">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="3">preis:4€</code><br><code class="fragment" data-fragment-index="3">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen</span></span></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen<br>(aktueller Wert)</span></span></p></div>
                    </div>
                    <aside class="notes">Ist $r + w \gt N$, überlappen sich das Read-Set und das Write-Set. Beim Lesen ist also in jedem Falle mindestens ein Knoten dabei, auf dem die neusten Daten bereits geschrieben wurden.</aside>
                </section>

                <section>
                    <h3>Eventual Consistency: $r + w \le N$</h3>
                    <p class="small">Beispiel: $r = 1, w = 2, N = 3$</p>
                    <div class="columns">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="3">preis:4€</code><br><code class="fragment" data-fragment-index="3">preis:5€</code><br><span class="fragment" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3">&uparrow; lesen<br>(veralteter Wert)</span></span></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                    </div>

                    <aside class="notes">Für alle Fälle, in denen $r + w \le N$ gilt, kann keine Konsistenz garantiert werden. Es kann sein, dass der Knoten, von dem man liest, noch nicht die Änderungen erhalten hat, die kürzlich geschrieben wurden.</aside>
                </section>

                <section>
                    <h2>ACID, BASE, CAP-Theorem</h2>
                    <h4>ACID</h4>
                    <ul>
                        <li><b>Atomarität</b><br>Alles-oder-Nichts-Prinzip​</li>
                        <li><b>Konsistenz</b><br>Transaktion hinterlässt konsistenten DB-Zustand​</li>
                        <li><b>Isolation</b><br>Parallel laufenden TAs beeinflussen sich nicht ​​</li>
                        <li><b>Dauerhaftigkeit</b><br>Committete Änderungen gehen nicht verloren​</li>
                    </ul>
                </section>

                <section>
                    <h2>ACID, BASE, CAP-Theorem</h2>
                    <h4>BASE</h4>
                    <ul style="width: 55cm;">
                        <li><b>Basically Available</b><br>DB akzeptiert und beantwortet Anfragen (meistens)​</li>
                        <li><b>Soft State</b><br>Es dauert, bis sich der DB-Zustand synchronisiert hat</li>
                        <li><b>Eventual Consistent</b><br>Irgendwann ist die DB wieder in konsistentem Zustand​​</li>
                    </ul>

                    <aside class="notes">Das Akronym BASE wird gerne vor allem in NoSQL-Datenbanken als Gegenstück für die strengen ACID-Eigenschaften verwendet, die vor allem meist in relationalen Datenbanken gefordert werden. Oft wird beispielsweise in Web-Anwendungen wie sozialen Netzwerken kein striktes ACID verlangt. Lockert man es auf und sagt, dass BASE ausreichend ist, kann dies zu enormen Performance-Vorteilen führen. Eventual Consistency wäre in ACID-DBs undenkbar. Soft State ebenso: Man liest zweimal das gleiche, niemand hat die Daten zwischenzeitlich geändert, trotzdem kommt zweimal was unterschiedliches raus.</aside>
                </section>

                <section>
                    <h2>ACID, BASE, CAP-Theorem</h2>
                    <h4>CAP-Theorem</h4>
                    <ul>
                        <li><b>Consistency</b> <br>DB liefert stets den aktuellen Wert</li>
                        <li><b>Availability</b> <br>DB liefert stets eine Antwort auf Anfragen</li>
                        <li><b>Partition Tolerance</b> <br>DB funktioniert auch, wenn mal etwas ausfällt</li>
                    </ul>
                    <p><b><em>Nur max. 2 dieser Eigenschaften lassen sich erreichen!</em></b></p>
                    <aside class="notes">Unter einer Netzwerkpartition versteht man, dass im Netzwerk ein Knoten einen anderen im Moment nicht erreichen kann, z. B. bei Netzwerkproblemen oder wenn der Knoten vorübergehend offline ist. Partition Tolerance bedeutet, dass das System in einem solchen Fall dennoch weiter funktioniert.</aside>
                </section>

                <section>
                    <h3>CAP-Theorem</h3>
                    <p class="small">In einem verteilten DBMS brauchen wir Partition Tolerance.<br>
                    Netzwerkpartitionen können nunmal auftreten.</p>

                    <div class="columns" style="margin-top:-3mm">
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><p class="small" style="margin-top: -10mm;"><code class="fragment fade-out" data-fragment-index="1">preis:4€</code><br><code class="fragment" data-fragment-index="1">preis:5€</code></p></div>
                        <div><h1><i class="fas fa-server red"></i></h1><p class="small" style="margin-top: -10mm;"><code>preis:4€</code></p></div>
                    </div>

                    <div class="fragment">
                    <h4 style="margin-top: -3mm; margin-bottom: -5mm;">CP: Consistency + Partition Tolerance</h4>
                    <p class="small">Warten, bis Knoten 3 sich wieder synchronisiert hat. &Rightarrow; keine Availability.</p>
                    </div>

                    <div class="fragment">
                    <h4 style="margin-top: -3mm; margin-bottom: -5mm;">AP: Availability + Partition Tolerance</h4>
                    <p class="small">Beim Lesen von Knoten 3 liest man veraltete Daten. &Rightarrow; keine Consistency.</p>
                    </div>

                    <aside class="notes">In MongoDB hat man die Wahl zwischen CP und AP über die Read Preference. Liest man vom Primary, hat man Konsistenz, liest man auch von Secondaries, hat man Availability. Standard ist also CP.</aside>
                </section>

                <section>
                    <h3>Binäre vs. Statement-basierte Replikation</h3>
                    <h4>Binäre Replikation</h4>
                    <p class="small">Master an Slaves nach jedem Write: "In Datei XYZ hat sich bei Offset 234 folgendes geändert: 0010101010010010001001010010010101001010001111101001010101"</p>
                    
                    <div class="fragment">
                    <h4>Statement-basierte Replikation &leftarrow; <img src="img/1/mongodb.png" class="noborder" style="margin-top:-5mm; margin-bottom:-5mm"></h4>
                    <ul class="small">
                        <li>Client schickt Write-Statement an Primary</li>
                        <li>Primary schreibt das Statement in die Collection <code>oplog.rs</code> (DB <code>local</code>)</li>
                        <li>Secondaries holen sich kontinuierlich Änderungen aus der Oplog<br>und führen sie aus</li>
                    </ul>
                    <p class="fragment small" style="width: 50cm; margin-top: 3mm;">(+) Verschiedene Storage-Engines auf Knoten möglich (z. B. In-Memory auf Primary)</p>
                    </div>
                    <aside class="notes">Binäre Replikation verursacht in der Regel weniger Datenverkehr über das Netzwerk. Dennoch verwendet MongoDB Statement-basierte Replikation. Hier werden statt konkreten binären Änderungen in der Datenbank lediglich die Statements an die Secondaries weitergeleitet.</aside>
                </section>

                <section>
                    <h3>Oplog</h3>
                    <p class="small">Beispiel: Ein neuer Kunde wird eingefügt.</p>
                    <pre style="width: 100%;"><code class="javascript">rs0:PRIMARY> db.kunden.insertOne( { name: "Peter" } )
WriteResult({ "nInserted" : 1 })</code></pre>

<div class="fragment">
                    <h4>Oplog (Capped Collection): <code>oplog.rs</code> in DB <code>local</code></h4>
                    <pre style="width: 100%;"><code class="javascript">rs0:PRIMARY> use local
rs0:PRIMARY> db.oplog.rs.find()
{
    "op" : "i",
    "ns" : "test.kunden",
    "ui" : UUID("ba043302-1592-4c7a-95b0-100a6c306457"),
    "o" : {
            "_id" : ObjectId("6197c6014f6105b1ed3555c9"),
            "name" : "Peter"
    },
    "ts" : Timestamp(1637336577, 1),
    // ...                    
}</code></pre>
</div>
    <aside class="notes">Die Insert-Operation taucht in der Oplog auf, jedoch ist dort auch der Wert des <code>_id</code>-Feldes angegeben, damit diese auf allen Knoten einheitlich ist und damit die Operation im Oplog idempotent ist. Idempotent heißt, es würde keinen Unterschied machen, ob man die Operation einfach oder mehrmals ausführt.</aside>
                </section>

                <section>
                    <h3>Oplog</h3>
                    <p class="small">Beispiel: Zwei Kunden werden gelöscht.</p>
                    <pre style="width: 100%;"><code class="javascript">rs0:PRIMARY> db.kunden.deleteMany( { name: {$in:["Peter", "Ute"]} } )
{ "acknowledged" : true, "deletedCount" : 2 }</code></pre>

                    <pre style="width: 100%;"><code class="javascript" style="max-height: 25cm;">{
    "op" : "d", "ns" : "test.kunden",
    "o" : {
            "_id" : ObjectId("6197bd854f6105b1ed3555c8")
    },
    "ts" : Timestamp(1637336633, 1),
    // ...
}
{
    "op" : "d", "ns" : "test.kunden",
    "o" : {
            "_id" : ObjectId("6197c6014f6105b1ed3555c9")
    },
    "ts" : Timestamp(1637336633, 2),
    // ...
}</code></pre>
<aside class="notes">Jede Operation im Oplog ist idempotent. Das eine <code>deleteMany</code>-Statement wurde aufgesplittet in zwei einzelne Deletes konkreter Dokumente unter Angabe ihrer <code>_id</code>s.</aside>
                </section>

                <section>
                    <h3>Automatischer Failover</h3>
                    <div class="columns small">
                        <div style="font-size:102%"><h1><div style="position: relative; margin-top:3mm;">
                            <i style="position: absolute;" class="fas fa-server blue fragment fade-out" data-fragment-index="1"></i>
                            <i style="position: absolute;" class="fas fa-server red fragment" data-fragment-index="1" data-badge="Ausfall!" data-badge-position="tl"></i>
                        </div></h1><div style="margin-top: 2.9cm; padding-left: 28mm;">Primary</div></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary
                        <div class="fragment" data-fragment-index="2" style="font-size:smaller">"Wir brauchen einen<br>neuen Master!"</div></div></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary
                            <div class="fragment" data-fragment-index="3"  style="font-size:smaller">"Ja, wir brauchen<br>einen neuen Master!"</div></div></div>
                    </div>
                    <p></p>

                    <div class="fragment" data-fragment-index="4">
                    <h4>Wahl eines neuen Masters</h4>
                    <p style="margin-top: -3mm;" class="small"><b>Consenus</b>: &#8532;-Mehrheit an Stimmen erforderlich, um neuen Master zu bestimmen.​</p>
                    </div>

                    <div class="columns fragment small" data-fragment-index="5">
                        <div style="font-size:102%"><h1><div style="position: relative; margin-top:3mm;">
                            <i style="position: absolute;" class="fas fa-server blue fragment" data-fragment-index="6"></i>
                            <i style="position: absolute;" class="fas fa-server red fragment fade-out" data-badge="Ausfall!" data-badge-position="tl" data-fragment-index="6"></i>
                        </div></h1><div style="margin-top: 2.9cm; padding-left: 28mm;" class="fragment" data-fragment-index="6">Secondary</div></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Primary</div></div>
                        <div><h1><i class="fas fa-server blue"></i></h1><div style="margin-top: -1cm;">Secondary</div></div>
                    </div>

                    <aside class="notes">Wenn der Primary ausfällt, merken das die Secondaries daran, dass sie von ihm keinen Heartbeat mehr bekommen bzw. daran, dass Pings nicht beantwortet werden. Slaves können aber auch zu unrecht denken, dass der Master ausgefallen ist, z.B. wenn die Netzwerkverbindung zwischen Master und einem Slave unterbrochen wird. Deshalb besagt der Consensus-Algorithmus, dass mindestens zwei drittel der Rechner der Meinung sein müssen, dass sie einen neuen Master brauchen. Erst dann wird ein neuer Master bestimmt. Einer der Secondaries wird dann zum Primary, also zum neuen Master.​ Ist der ausgefallene Knoten wieder verfügbar, wird er selbst zum Secondary und bringt sich wieder mithilfe der Oplog des Masters auf den aktuellen Stand.</aside>
                    
                </section>

                <section>
                    <h3>Wer wird Primary?</h3>
                    <h4>Priorities</h4>
                    <p class="small" style="margin-top: -3mm;">Höhere Priority &Rightarrow; höhere Wahrscheinlichkeit zum Master gewählt zu werden.</p>
                    <pre><code class="javascript">cfg = rs.conf()
cfg.members[0].priority = 0.5
cfg.members[1].priority = 2
cfg.members[2].priority = 2
rs.reconfig(cfg)</code></pre>

<div class="fragment">
    <h4><code>rs.stepDown()</code></h4>
    <p class="small" style="margin-top: -3mm;">Damit wird der Primary nun zum Secondary.</p>
    <pre><code class="plaintext">rs0:PRIMARY> rs.stepDown()
rs0:SECONDARY></code></pre>
</div>
                </section>
			</div>
		</div>

		<script src="reveal.js/dist/reveal.js"></script>
		<script src="reveal.js/plugin/markdown/markdown.js"></script>
		<script src="reveal.js/plugin/highlight/highlight.js"></script>
		<script src="reveal.js/plugin/zoom/zoom.js"></script>
		<script src="reveal.js/plugin/math/math.js"></script>
		<script src="reveal.js/plugin/notes/notes.js"></script>
		<script src="reveal.js/plugin/search/search.js"></script>
        <script src="lib/jquery.js"></script>
        <script src="lib/lodash.js"></script>
        <script src="lib/backbone.js"></script>
        <script src="lib/joint.min.js"></script>
				<script src="lib/deflate.js"></script>

		<script src="src/init_reveal.js"></script>

        <script>
        if(window.location.search.match( /print-pdf/gi )) {
                document.getElementById('header').style="display:none";
                document.getElementById('footer').style="display:none";
        }
        </script>


	</body>
</html>

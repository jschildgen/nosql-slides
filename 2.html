<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>NoSQL-Datenbanken - Kapitel 2 - MongoDB</title>

		<link rel="stylesheet" href="reveal.js/dist/reset.css">
		<link rel="stylesheet" href="reveal.js/dist/reveal.css">

        <link rel="stylesheet" href="src/slides.css">
        <link rel="stylesheet" href="src/sql.css">

		<link rel="stylesheet" href="src/layout.css">
        <link rel="stylesheet" href="lib/joint.min.css" />
        <link rel="stylesheet" href="src/erd.css" />
        <link rel="stylesheet" href="src/poll.css" />

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="src/rainbow.css">

        <!--<script defer src="lib/fontawesome.all.min.js"/>-->
        <link href="lib/fontawesome.all.min.css" rel="stylesheet">
        <style> .reveal i.fa { font-family:FontAwesome; font-style: normal; } </style>
	</head>
	<body>
		<div class="reveal">
            <div id="header"></div>
            <div id="footer"></div>
			<div class="slides">
                <section>
                    <h4 style="text-align:center"><b>Prof. Dr.-Ing. Johannes Schildgen</b><br>
                    <a href="mailto:johannes.schildgen@oth-regensburg.de">johannes.schildgen@oth-regensburg.de</a></h4>
                    <h2>NoSQL-Datenbanken</h2>
                    <h4 style="text-align:center">&nbsp;</h4>
                    <h3>Kapitel 2: MongoDB</h3>
                    <h4 style="text-align:center">&nbsp;<br>&nbsp;</h4>
                    <img src="img/ccby.png" height="60px" style="position: absolute; left:0px; border:0; bottom:-160px;">
                    <img src="img/oth.png" height="60px" style="position: absolute; right:0px; border:0; bottom:-160px; box-shadow:none">
                </section>
                
								<section>
									<h3>Ziel der Vorlesung</h3>
									
									<ul class="small">
										<li>Konzepte von NoSQL-Datenbanken am Beispiel von MongoDB lernen
											<ul>
												<li>Datenmodellierung</li>
												<li>Replikation, Sharding</li>
												<li>Performance: Anfragepläne, Indexe, Profiling</li>
												<li>Transaktionen: ACID vs. BASE, CAP-Theorem</li>
											</ul><br>
										</li>
										<li class="fragment">Vorbereitung für die MongoDB Developer-Zertifizierung (freiwillig)
											<img src="img/2/githubsdp-plus-mongodb.png" alt="GitHub Student Developer Pack" class="noborder" style="position: absolute; right: -0.1cm; top: 8.5cm; width: 8cm;">
											<ul>
												<li>Mongo Professional Certification</li>
												<li>Vorlesungsinhalte = Zertifizierungsinhalte</li>
												<li>Dauer: 90 Minuten, Multiple-Choice, online</li>
												<li>Kosten: <strike>150 USD</strike> (kostenlos für Studierende: <a href="https://www.mongodb.com/students">mongodb.com/students</a>) </li>
											</ul>
										</li>
									</ul>
									<aside class="notes">Die Konzepte von NoSQL-Datenbanken werden im Rahmen der nun folgenden Vorlesungskapitel am Beispiel von MongoDB detailliert behandelt. Die Inhalte decken den kompletten Stoff ab, der in der MongoDB Developer-Zertifizierung abgefragt wird. Die Teilnahme und das Bestehen der Zertifizierungsprüfung ist unabhängig vom FWPM NoSQL-Datenbanken und keine Prüfungsvoraussetzung. MongoDB ist Teil des GitHub Student Developer Packs, sodass Studierende die Zertifizierung kostenlos mitmachen können: <a href="https://education.github.com/pack" target="_blank">https://education.github.com/pack</a></aside>
								</section>

								<section>
									<h2><img src="img/1/mongodb.png" alt="MongoDB" class="noborder" style="width: 8cm; margin-bottom: -0.5cm;"></h2>
									<p class="small">Die populärste NoSQL-Datenbank.</p>
									<ul class="small">
										<li>Erschienen: 2009 (aktuelle Version MongoDB 5)</li>
										<li>Open-Source</li>
										<li>Kategorie: Dokumentenorientierte Datenbank</li>
										<li>Datenmodell: Sammlung JSON-ähnlicher Dokumente</li>
									</ul>
									<aside class="notes">Der Name MongoDB kommt vom Wort humongous (gigantisch) und verdeutlicht, dass die NoSQL-Datenbank für die Sammlung großer Datenmengen geeignet ist. MongoDB ist die am meisten verbreitete NoSQL-Datenbank.</aside>
								</section>

								<section>
									<h3>Installation von MongoDB</h3>
									<p class="small">Über Paketmanager:</p>
									<pre><code class="sh">sudo apt install mongodb                # Ubuntu
choco install mongodb                   # Windows (Chocolatey)</code></pre>

<div class="fragment">
									<p class="small">Manuelle Installation:</p>
									<ul class="small">
									<li><a href="https://www.mongodb.com/" target="_blank">mongodb.com</a> &rightarrow; Kostenlos testen &rightarrow; On-premises &rightarrow; MongoDB Community Server &rightarrow; Windows &rightarrow; msi / Ubuntu &rightarrow; shell (deb)</li>
									</ul>
</div>									
<div class="fragment">
									<p class="small">Ohne Installation:</p>
									<ul class="small">
										<li>zip- bzw. tgz-Datei herunterladen und entpacken</li>
										</ul>
</div>
<div class="fragment">
	<img src="img/2/MongoDB-Atlas-Logo-Black-hvfxuesorm.svg" alt="MongoDB Atlas" class="noborder" style="position: absolute; right: -0.1cm; top: 13cm; width: 8cm;">
										<p class="small">In der Cloud (MongoDB Atlas):</p>
										<ul class="small">
											<li><a href="https://www.mongodb.com/de-de/cloud/atlas" target="_blank">https://www.mongodb.com/de-de/cloud/atlas</a></li>
											<li>Automatisierte Einrichtung von Servern, Skalierung, Backups, ...</li>
											<li>200 USD Startguthaben im GitHub Student Development Pack</li>
											</ul>
</div>
								</section>

								<section>
									<h3>Programme</h3>
									<h4><code>mongod</code></h4>
									<p class="small" style="margin-top: -5mm;">MongoDB Server ("MongoDB Deamon")</p>
									<pre style="width: 103%;"><code class="plaintext">./mongod --port 27017 --dbpath /data/db          # oder einfach ./mongod
{..., "msg":"Waiting for connections","attr":{"port":27017,"ssl":"off"}}</code></pre>

<div class="fragment">
<h4><code>mongo</code></h4>
									<p class="small" style="margin-top: -5mm;">Mongo Shell (Command-Line-Interface)</p>
									<pre style="width: 103%;"><code class="plaintext">./mongo
> db.produkte.insert({"bezeichnung":"Schokoriegel", "preis": 0.89})
WriteResult({ "nInserted" : 1 })</code></pre>
</div>

<div class="fragment">
<h4><code>mongos</code></h4>
									<p class="small" style="margin-top: -5mm;">MongoDB Sharding Server (mehr dazu im Kapitel über Sharding)</p>
</div>
									<aside class="notes">Wählt man die Variante ohne Installation über die Zip-Datei, befindet sich in dieser ein bin-Ordner mit den Programmen mongod.exe, mongo.exe und mongos.exe (unter Windows). Diese sind auf der Kommandozeile auszuführen. Unter Windows z. B. in der PowerShell oder mit Cmder.</aside>
								</section>

								<section>
									<h3>JSON (JavaScript Object Notation)</h3>
									<p class="small">6 JSON-Datentypen:</p>
									<table class="small"  style="margin-top: -4mm; margin-bottom: -4mm;">
										<tbody>
											<tr><td>String</td><td><code>"hallo"</code></td></tr>
											<tr><td>Zahl</td><td><code>3.5</code></td></tr>
											<tr><td>Boolean</td><td><code>true</code></td></tr>
											<tr><td>Objekt (Dokument)</td><td><code>{"a":5, "b":10}</code></td></tr>
											<tr><td>Array</td><td><code>[11,21,"Hallo",false]</code></td></tr>
											<tr><td>Null</td><td><code>null</code></td></tr>
										</tbody>
									</table>

									<pre><code class="json">{"name":"Ute", "admin": true, "kinder": [], "job": null,
 "adressen": [ {"strasse":"Bergstr.", "hausnr": 25},
               {"strasse":"Hauptstr.", "hausnr": 17}] }</code></pre>
							 <aside class="notes">Arrays können beliebige Elemente beliebigen Typs besitzen. Objekte bestehen aus Feld-Wert-Paaren. Feldnamen sind innerhalb eines Objekts eindeutig, Werte können von einem beliebigen Typen sein. MongoDB verwendet neben den hier gezeigten 6 JSON-Datentypen noch ein Paar weitere (für Datum, Binärdaten, Timestamps, reguläre Ausdrücke, ...). In der Mongo Shell darf man die Anführungszeichen bei Feldnamen weglassen, wenn diese keine speziellen Zeichen beinhalten ($ ist ok).</aside>
								</section>

								<section>
									<h3>MongoDB-Dokumente</h3>
									<ul class="small" style="margin-bottom: 3mm;">
										<li>Jedes Dokument hat das Feld <code>_id</code> (Primärschlüssel)</li>
										<li>Datentypen: die 6 JSON-Typen + einige weitere</li>
									</ul>

									<div class="fragment">
									<h4><code>Double</code> (64-bit-Zahl)</h4>
									<p class="small" style="margin-top: -5mm;">Wird standardmäßig für Zahlen verwendet und kann zu Rundungsfehlern führen.</p>
									<pre style="width:100%"><code class="javascript">> db.zahlen.insert( { _id: 9999999.4999999999 } )
> db.zahlen.find()
{ "_id" : 9999999.5 }</code></pre>
</div>

<div class="fragment">
									<h4><code>NumberDecimal</code> (128-bit-Zahl)</h4>
									<pre style="width:100%; margin-top: -5mm;"><code class="javascript">> db.zahlen.insert( { _id: NumberDecimal("9999999.4999999999") } )
> db.zahlen.find()
{ "_id" : NumberDecimal("9999999.4999999999") }</code></pre>
</div>
<aside class="notes">Es wird empfohlen, den Konstruktor von NumberDecimal mit einem String aufzurufen, nicht mit einer Zahl, da diese ja bereits ein Double ist und daher Genauigkeit verloren gehen kann.</aside>
								</section>

								<section>
									<h2>BSON</h2>
									<p class="small">Binary JSON</p>
									<p class="small">Internes Speicherformat, was schnellere Suchen auf Dokumenten ermöglicht.</p>
									<pre><code class="javascript">{ "_id": 17, "bezeichnung": "Schokoriegel" }</code></pre>
									<table class="small">
										<tr><td>length</td><td>type</td><td>field</td><td>value</td><td>type</td><td>field</td><td>length</td><td>value</td><td>EOD</td></tr>
										<tr style="font-family: monospace; font-size: 16pt;"><td>45</td><td>16</td><td>_id\0</td><td>17</td><td>2</td><td>bezeichnung\0</td><td>12</td><td>Schokoriegel\0</td><td>\0</td></tr>
										<tr><td>4 Bytes</td><td>1</td><td>4</td><td>4</td><td>1</td><td>12</td><td>4</td><td>13</td><td>1</td></tr>
									</table>
									<div class="poll fragment fade-in-then-out" style="top:10px; height: 9.5cm;" data-fragment-index="1">
										<h1>Wie viel Prozent mehr oder weniger Platz benötigt die BSON-Repräsentation im vergleich zum JSON-String?</h1>
												<ul>
														<li>27% weniger</li>
														<li data-poll="correct">gleich viel</li>
														<li>11% mehr</li>
												</ul>
										<h2>https://fraage.de</h2>
									</div>
					
									<aside class="notes">BSON ist ein von MongoDB eingeführtes Speicherformat. In MongoDB werden Dokumente nämlich nicht als JSON-Strings abgespeichert, sondern in einer binären Form, wie diese Folie zeigt. Dies macht schnellere Suchen möglich. Das Längenfeld ganz am Anfang ist nützlich, um ein kompletten Dokument vollständig zu überspringen und direkt zum nächsten Dokument zu springen. Das gleiche gilt für die Längenangaben von String-Feldern. Mit dieser Info kann schnell zum nächsten Attribut gesprungen werden.</aside>
								</section>

								<section>
									<h3>Datenbanken und Collections</h3>
									<div class="sl-block" data-block-type="shape" data-block-id="2121ed019183690fcbf4d59ebf307854" style="min-width: 4px; min-height: 4px; width: 245px; height: 152.5px; left: 671px; top: 184px;">
										<div class="sl-block-content" data-shape-type="rect" data-shape-fill-color="rgb(111, 168, 220)" data-shape-stretch="true" style="z-index: 11;"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 153">
														<rect width="245" height="152.5" rx="0" ry="0" class="shape-element" fill="rgb(111, 168, 220)"></rect>
												</svg></div>
								</div>
								<div class="sl-block" data-block-type="shape" style="min-width: 4px; min-height: 4px; width: 245px; height: 45px; left: 671px; top: 161px;" data-block-id="6fbcffef94ac35b1a289820d4da4a3c7">
										<div class="sl-block-content" data-shape-type="circle" data-shape-fill-color="rgb(109, 158, 235)" data-shape-stretch="true" style="z-index: 12;" data-shape-stroke-color="#000000" data-shape-stroke-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 45">
														<defs>
																<clipPath id="shape-mask-5-1569275407016">
																		<ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" fill="rgb(109, 158, 235)" stroke="#000000" stroke-width="10"></ellipse>
																</clipPath>
														</defs>
														<ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" class="shape-element" fill="rgb(109, 158, 235)" stroke="#000000" stroke-width="10" clip-path="url(#shape-mask-5-1569275407016)"></ellipse>
												</svg></div>
								</div>
								<div class="sl-block" data-block-type="shape" style="min-width: 4px; min-height: 4px; width: 245px; height: 45px; left: 670px; top: 314px;" data-block-id="5ea1aa800f8cffe0cfcd668051167951">
										<div class="sl-block-content" data-shape-type="circle" data-shape-fill-color="rgb(111, 168, 220)" data-shape-stretch="true" style="z-index: 10;" data-shape-stroke-color="#000000" data-shape-stroke-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 45">
														<defs>
																<clipPath id="shape-mask-6-1569275422813">
																		<ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" fill="rgb(111, 168, 220)" stroke="#000000" stroke-width="10"></ellipse>
																</clipPath>
														</defs>
														<ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" class="shape-element" fill="rgb(111, 168, 220)" stroke="#000000" stroke-width="10" clip-path="url(#shape-mask-6-1569275422813)"></ellipse>
												</svg></div>
								</div>
								<div class="sl-block" data-block-type="line" style="width: auto; height: auto; min-width: 1px; min-height: 1px; left: 670px; top: 184px;" data-block-id="dfef938d157782f2c4686c5b0fee9f03">
										<div class="sl-block-content" data-line-x1="0" data-line-y1="152.5" data-line-x2="1" data-line-y2="0" data-line-color="#000000" data-line-start-type="none" data-line-end-type="none" style="z-index: 13;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="152.5" viewBox="0 0 1 152.5">
														<line stroke="rgba(0,0,0,0)" stroke-width="15" x1="0.5" y1="153" x2="1.5" y2="0.5"></line>
														<line class="line-element" stroke="#000000" stroke-width="5" x1="0.5" y1="153" x2="1.5" y2="0.5"></line>
												</svg></div>
								</div>
								<div class="sl-block" data-block-type="line" style="width: auto; height: auto; min-width: 1px; min-height: 1px; left: 915px; top: 184px;" data-block-id="a9efdff789a6eab3c8fc93c68b0c09ce">
										<div class="sl-block-content" data-line-x1="0" data-line-y1="152.5" data-line-x2="0" data-line-y2="0" data-line-color="#000000" data-line-start-type="none" data-line-end-type="none" style="z-index: 14;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="152.5" viewBox="0 0 1 152.5">
														<line stroke="rgba(0,0,0,0)" stroke-width="15" x1="0.5" y1="153" x2="0.5" y2="0.5"></line>
														<line class="line-element" stroke="#000000" stroke-width="5" x1="0.5" y1="153" x2="0.5" y2="0.5"></line>
												</svg></div>
								</div>
								
								
								<div class="sl-block" data-block-type="shape" data-name="shape-0eba5a" data-block-id="a9d5cec9e7c9577db95f1957028817f9" style="width: 176px; height: 70px; left: 689px; top: 225.25px;">
										<div class="sl-block-content" data-shape-type="rect" data-shape-fill-color="rgb(68, 170, 171)" data-shape-stretch="true" style="z-index: 15;" data-shape-stroke-color="#000000" data-shape-stroke-width="1px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 176 70">
														<defs>
																<clipPath id="shape-mask-1-1632802709529">
																		<rect width="176" height="70" rx="0" ry="0" fill="rgb(68, 170, 171)" stroke="#000000" stroke-width="2"></rect>
																</clipPath>
														</defs>
														<rect width="176" height="70" rx="0" ry="0" class="shape-element" fill="rgb(68, 170, 171)" stroke="#000000" stroke-width="2" clip-path="url(#shape-mask-1-1632802709529)"></rect>
												</svg></div>
								</div>
								<div class="sl-block" data-block-type="shape" style="width: 176px; height: 70px; left: 705.5px; top: 247px;" data-block-id="d30e787f2c0d86d0df8ffeec261a0904" data-name="shape-b2b4d7">
										<div class="sl-block-content" data-shape-type="rect" data-shape-fill-color="rgb(68, 170, 171)" data-shape-stretch="true" style="z-index: 16;" data-shape-stroke-color="#000000" data-shape-stroke-width="1px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 176 70">
														<defs>
																<clipPath id="shape-mask-2-1632802714746">
																		<rect width="176" height="70" rx="0" ry="0" fill="rgb(68, 170, 171)" stroke="#000000" stroke-width="2"></rect>
																</clipPath>
														</defs>
														<rect width="176" height="70" rx="0" ry="0" class="shape-element" fill="rgb(68, 170, 171)" stroke="#000000" stroke-width="2" clip-path="url(#shape-mask-2-1632802714746)"></rect>
												</svg></div>
								</div>
								<div class="sl-block" data-block-type="shape" style="width: 176px; height: 70px; left: 725px; top: 266px;" data-block-id="3468e2a599a1707a47e2b3873861ce06" data-name="shape-2d79a1">
										<div class="sl-block-content" data-shape-type="rect" data-shape-fill-color="rgb(68, 170, 171)" data-shape-stretch="true" style="z-index: 17;" data-shape-stroke-color="#000000" data-shape-stroke-width="1px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 176 70">
														<defs>
																<clipPath id="shape-mask-3-1632802718230">
																		<rect width="176" height="70" rx="0" ry="0" fill="rgb(68, 170, 171)" stroke="#000000" stroke-width="2"></rect>
																</clipPath>
														</defs>
														<rect width="176" height="70" rx="0" ry="0" class="shape-element" fill="rgb(68, 170, 171)" stroke="#000000" stroke-width="2" clip-path="url(#shape-mask-3-1632802718230)"></rect>
												</svg></div>
								</div>
								<div class="sl-block" data-block-type="text" data-name="text-df55fd" data-block-id="bba1b51f13b2f4a6e3160a3eeff88ad7" style="height: auto; width: 167px; left: 725px; top: 260.25px;">
										<div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 18;" dir="ui">
												<p style="font-size:0.7em; text-align: center; margin-top: 1mm;">Collection</p>
												<p style="font-size:0.7em; text-align: center; margin-top: -6mm;">"produkte"</p>
										</div>
								</div>
								<div class="sl-block" data-block-type="text" style="height: auto; width: 239px; left: 673px; top: 359px;" data-block-id="dfa35455ba955887c6e7e3c893a2b52c" data-name="text-16952c">
										<div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 19;" dir="ui">
											<p style="font-size:0.7em; text-align: center; margin-top: 1mm;">db "webshop"</p>
										</div>
								</div>
								<p class="small">Eine MongoDB-Instanz beinhaltet mehrere Datenbanken,<br>
								                 eine Datenbank beinhaltet Collections,<br>
																 eine Collection speichert Dokumente.</p>

									<pre class="fragment" style="width: 17cm; margin-left: 0cm;"><code class="javascript">> db
test

> show dbs
admin    0.000GB
config   0.000GB
local    0.000GB
webshop  0.000GB

> use webshop
switched to db webshop

> show collections
produkte</code></pre>

<aside class="notes">Diese Folie zeigt vier Mongo-Shell-Kommandos. <code>db</code> zeigt, welche Datenbank aktuell ausgewählt ist, <code>show dbs</code> zeigt alle Datenbanken an, mit <code>use</code> kann die Datenbank gewechselt werden. Man kann auch zu einer Datenbank wechseln, die es noch gar nicht gibt. Sobald man darin zum ersten Mal schreibt, legt MongoDB die Datenbank automatisch an. <code>show collections</code> listet alle Collections in der aktuell geöffneten DB. </aside>
								</section>

								<section>
									<h3><code>findOne</code></h3>
									<h4><code>findOne([selektion], [projektion])</code></h4>
									<p class="small">Liefert ein Dokument zurück, was das Selektionskriterium erfüllt.</p>
									<pre class="fragment"><code class="javascript">> db.produkte.findOne()
{ "_id" : 17, "bezeichnung" : "Schokoriegel", "preis" : 0.89 }</code></pre>

<pre class="fragment"><code class="javascript">> p = db.produkte.findOne({ "_id": 29 }, {"bezeichnung": 1})
{ "_id" : 29, "bezeichnung" : "Spülmaschinentabs" }
> p._id
29
</code></pre>
<div class="columns fragment">
	<div><h4>Selektion</h4>
	<p class="small">Feld-Überprüfungen auf Gleichheit:<br><code>{ "feld": "wert" }</code></p>
</div>
	<div class="fragment"><h4>Projektion</h4>
	<p class="small"><code>{ "feld": 1 }</code> (nur diese Felder)<br>// das <code>_id</code>-Feld ist aber dennoch dabei<br>
		<code>{ "feld": 0 }</code> (diese Felder nicht)</p>
</div>
</div>
<aside class="notes">Die Mongo Shell versteht JavaScript. Das untere Beispiel auf dieser Folie zeigt, wie das Ergebnis eines <code>findOne</code>-Befehls (ein Objekt) in eine Variable geschrieben werden kann.</aside>
</section>

								<section>
									<h3><code>find</code></h3>
									<h4><code>find([selektion], [projektion])</code></h4>
									<p class="small">Liefert einen Cursor zurück, zur Iteration über die Ergebnismenge.</p>
									<pre class="fragment"><code class="plaintext">> db.produkte.find()
// ... (listet 20 Dokumente auf)
Type "it" for more
> it
// ... (die nächsten 20)</code></pre>

									<pre class="fragment"><code class="javascript">> db.produkte.find().forEach(function(p) { print(p._id) })</code></pre>

</section>

<section>
	<h3>Cursor-Methoden</h3>
	<ul class="small">
		<li><code>cursor.pretty()</code> - Besser lesbare Ausgabe</li>
		<li><code>cursor.sort({"feld":1})</code> - Aufsteigend sortieren (absteigend: -1)</li>
		<li><code>cursor.limit(n)</code></li>
		<li><code>cursor.skip(offset)</code> - Cursor beginnt erst nach der gegebenen Anzahl</li>
		<li><code>cursor.count()</code> - Anzahl der vom Cursor referenzierten Dokumente</li>
	</ul>
	<pre style="width: 100%;"><code class="javascript">> db.produkte.find().sort({"preis":-1}).limit(1).skip(1).pretty()
{
  "_id" : 18,
  "bezeichnung" : "Müsliriegel",
  "preis" : 1.19,
  "hersteller" : {
    "firma" : "Monsterfood",
    "land" : "USA"
  }
}</code></pre>

<div class="poll fragment" style="bottom: -100px; width: 9.5cm;">
	<h1>Was findet die auf der Folie gezeigte Query?</h1>
			<ul>
				<li>Das billigste Produkte</li>
				<li>Das zweitbilligste Produkte</li>
					<li>Das teuerste Produkt</li>
					<li data-poll="correct">Das zweitteuerste Produkt</li>
			</ul>
	<h2>https://fraage.de</h2>
</div>

<aside class="notes"><code>sort</code> kann ähnlich wie <code>ORDER BY</code> in SQL auch nach mehreren Kriterien sortieren. Die Reihenfolge der Sortierkriterien ist relevant. Die hier gezeigte Anfrage sucht zunächst alle Dokumente in der Collection "produkte", sortiert die Ergebnismenge absteigend nach Preis, überspringt ein Dokument (also das teuerste Produkt) und gibt nur ein Dokument aus. Gefunden wird also das zweitteuerste Produkt.</aside>
</section>

<section>
	<h3><code>cursor.allowDiskUse()</code></h3>
	<p class="small">Sortierungen erfolgen in-memory. Limit für temporäre Daten: 100 MB</p>
	<pre style="width: 100%;"><code class="javascript">db.bestellungen.find().sort({"zeit":-1})</code></pre>
	<p style="font-size: 60%; margin-top: -3mm;"><i class="red">Error: Exceeded memory limit.</i></p> 

	<pre style="width: 100%;"><code class="javascript">db.bestellungen.find().sort({"zeit":-1}).allowDiskUse()</code></pre>
</section>

<section>
	<h3>Selektion</h3>
	<div style="position: absolute; top: -1cm; right:5px; font-size:170px" class="green">&sigma;</div>
	<pre style="width: 20cm; margin-left: 0;"><code class="javascript">db.produkte.find({"preis": 0.89})</code></pre>
	<div class="fragment">
	<p class="small">Mehrere Kriterien &RightArrow; UND-Verknüpfung</p>
	<pre style="width: 24cm; margin-left: 0; margin-top: -4mm;"><code class="javascript">db.produkte.find({"preis": 0.89, "bezeichnung": "Schokoriegel"})</code></pre>
</div>
<div class="fragment">
	<p class="small">Vergleichsoperatoren: <code>$eq</code>, <code>$gt</code>, <code>$gte</code>, <code>$in</code>, <code>$lt</code>, <code>$lte</code>, <code>$ne</code>, <code>$nin</code></p>
	<pre style="width: 24cm; margin-left: 0; margin-top: -4mm;"><code class="javascript">db.produkte.find({"preis": { "$gt": 1.50 }})</code></pre>
	<pre class="fragment" style="width: 24cm; margin-left: 0; margin-top: -4mm;"><code class="javascript">db.produkte.find({"preis": { "$gte": 1, "$lte":2 }})</code></pre>
</div>
<div class="fragment">
	<p class="small">Logische Operatoren: <code>$and</code>, <code>$not</code>, <code>$nor</code>, <code>$or</code></p>
	<pre style="width: 24cm; margin-left: 0; margin-top: -4mm;"><code class="javascript">db.produkte.find({"$or" : [ {"bezeichnung": "Schokoriegel"},
                            {"bezeichnung": "Müsliriegel"} ] })</code></pre>
</div>

<div class="poll fragment" style="bottom: -180px; width: 9.5cm;">
	<h1>Was ist äquivalent zur unteren Anfrage auf der Folie?</h1>
			<ul>
				<li>db.produkte.find({"bezeichnung": "Schokoriegel", "bezeichnung": "Müsliriegel"})</li>
				<li data-poll="correct">db.produkte.find({"bezeichnung": {"$in": ["Schokoriegel", "Müsliriegel"]}})</li>
					<li>db.produkte.find({"$in": {"bezeichnung": ["Schokoriegel", "Müsliriegel"]}})</li>
			</ul>
	<h2></h2>
</div>
<aside class="notes">Die hier gezeigten Anfragen finden (1) Produkte, die 89ct kosten, (2) Produkte die 89ct kosten und die Bezeichnung Schokoriegel haben, (3) mehr als 1.50 EUR kosten, (4) zwischen 1 und 2 EUR kosten, (5) entweder die Bezeichnung Schokoriegel oder Müsliriegel haben.</aside>	
</section>

<section>
	<h3><code>$regex</code> - Reguläre Ausdrücke</h3>
	<p class="small">Reguläre Ausdrücke ermöglichen eine Muster-basierte Suche.</p>
	<pre><code class="javascript">db.produkte.find({bezeichnung:{$regex: /^S.*/}})</code></pre>
	<div class="columns small">
		<div>
			<table>
				<tr><td><code>.</code></td><td>Beliebiges Zeichen</td></tr>
				<tr><td><code>^</code></td><td>String-Anfang</td></tr>
				<tr><td><code>$</code></td><td>String-Ende</td></tr>
				<tr><td><code>[0-9a-c\.,]</code></td><td>Eines der Zeichen</td></tr>
				<tr><td><code>[^0-9a-c\.,]</code></td><td>Alle Zeichen, außer diese</td></tr>
				<tr><td><code>A|S</code></td><td>Regex A oder S</td></tr>
			</table>
		</div>
		<div>
			<table>
				<tr><td><code>*</code></td><td>0 mal oder öfter</td></tr>
				<tr><td><code>+</code></td><td>Mind. einmal</td></tr>
				<tr><td><code>?</code></td><td>Keinmal oder einmal</td></tr>
				<tr><td><code>{m}</code></td><td>Genau m mal</td></tr>
				<tr><td><code>{m,n}</code></td><td>Zwischen m und n mal</td></tr>
				<tr><td><code>{m,}</code></td><td>Mind. m mal</td></tr>
			</table>
		</div>
	</div>
	<pre style="margin-top: -1mm;"><code class="javascript">db.kunden.find({email:{$not:{$regex:
 /^[A-za-z0-9_\-\.\+]+@[A-Za-z0-9\-\.]+\.[a-zA-Z]{2,}$/}}})</code></pre>
 <aside class="notes">Die untere Anfrage findet Kunden mit einer potenziell ungültigen E-Mail-Adresse (der Ausdruck ist nicht perfekt). Vor dem @-Zeichen stehen mind. 1 der angegebenen Zeichen, danach ebenfalls, dann kommt ein Punkt und noch mind. zwei Buchstaben. Mit \ werden spezielle Zeichen (wie .) escapet.</aside>
</section>

<section>
	<h3><code>db.collection.distinct</code></h3>
	<p class="small" style="width: 103%;"><code class="javascript">{ "_id": 17, "bezeichnung": "Schokoriegel", "preis": 0.89,<br>
&nbsp;&nbsp;"hersteller": "Monsterfood" }<br>
{ "_id": 18, "bezeichnung": "Müsliriegel", "preis": 1.19,<br>
&nbsp;&nbsp;"hersteller": "Monsterfood" }<br>
{ "_id": 88, "bezeichnung": "Katzenfutter", "preis": 3.99,<br>
&nbsp;&nbsp;"hersteller": "Catcat" }</code></p>
		
	<h4><code>db.collection.distinct(feld, [query])</code></h4>
	<pre style="margin-top: -2mm;"><code class="javascript">> db.produkte.distinct("hersteller")
[ "Catcat", "Monsterfood" ]</code></pre>
<pre><code class="javascript">> db.produkte.distinct("hersteller", {"preis":{$gt:2}})
[ "Catcat" ]</code></pre>
<aside class="notes">Mit distinct lassen sich die distinkten Werte eines Felds abrufen. Übergibt man als zweiten Parameter ein Selektionskriterium, werden nur diejenigen Dokumente betrachtet, die dieses Kriterium erfüllen. <code>distinct</code> funktioniert auch für Subattribute und Array-Felder. Bei Arrays kommen die verschiedenen in den Arrays befindlichen Elemente heraus.</aside>
</section>

<section>
	<h3><code>insert</code> - Einfügen von Dokumenten</h3>
	<p class="small">Das Feld <code>_id</code> ist Pflicht und eindeutig.<br>
		Fehlt es, wird automatisch eine ObjectId generiert.</p>
	<pre><code class="javascript">db.kunden.insert({"name":"Ulf", "geboren":1985})</code></pre>
	<div class="fragment">
	<p class="small">Manuell setzen geht natürlich auch...</p>
	<pre><code class="javascript">db.kunden.insert({"_id": 5, "name":"Pia", "geboren":1972})</code></pre>
</div>
	<div class="fragment">
	<p class="small">... solange sie eindeutig ist!</p>
	<pre><code class="javascript">db.kunden.insert({"_id": 5, "name":"Kai", "geboren":1980})</code></pre>
	<p style="font-size: 60%;"><i class="red">E11000 duplicate key error collection: webshop.kunden index: _id_ dup key: { _id: 5.0 }</i></p>
</div>
<div class="fragment">
	<h4><code>insertMany(Array&lt;document&gt;)</code></h4>
	<pre><code class="javascript">db.kunden.insertMany([{"name":"Peter"},{"name":"Ute"}])</code></pre>
</div>
	<aside class="notes">Fügt man etwas in eine Collection ein, die noch nicht existiert, wird sie automatisch neu angelegt.</aside>
</section>

<section>
	<h3><code>update</code> - Ersetzen von Dokumenten</h3>
	<h4>update(kriterium, neues_dokument)</h4>
	<pre><code class="javascript">db.kunden.update( {"_id":5}, { "geboren": 1973 } )</code></pre>
	<p class="small">Vorher: <code class="javascript">{ "_id" : 5, "name" : "Pia", "geboren" : 1972 }</code>
	<br>Nachher: <code class="javascript">{ "_id" : 5, "geboren" : 1973 }</code></p>
	
	<div class="fragment">
	<p class="small">Ein Ansatz: Dokument holen, lokal modifizieren, zurückschreiben</p>
	<pre><code class="javascript">kunde = db.kunden.findOne( { "_id":5 });
kunde.geboren = 1973;
db.kunden.update({"_id": kunde._id}, kunde);</code></pre>
</div>
<div class="poll fragment" style="bottom: -180px; width: 9.5cm;">
	<h1>Warum steht unten nicht {"_id": 5} als Kriterium?</h1>
			<ul>
				<li data-poll="correct">Ginge auch, so ist's aber cooler</li>
				<li>Das wäre ein ungültiges Kriterium</li>
				<li>Dann würde man den _id-Wert ändern</li>
				<li>Dann gäbe es die _id zweimal, geht also nicht</li>
			</ul>
	<h2></h2>
</div>
</section>

<section>
	<h3><code>update</code> - Modifikatoren</h3>
	<h4><code>$set</code>, <code>$inc</code>, <code>$rename</code>, <code>$unset</code>, ...</h4>
	<pre><code class="javascript">db.kunden.update({"_id": 5}, {$set: {geboren:1973}})</code></pre>

	<div class="fragment" style="margin-top: 10mm;">
		<h4><code>$push</code>, <code>$addToSet</code>, <code>$pull</code>, ... (für Arrays)</h4>
		<pre><code class="javascript">db.kunden.update({"_id": 5}, {$push: {telefon:"0176123"}})</code></pre>
	</div>

	<aside class="notes">Die hier gezeigten Operatoren werden verwendet, um Teile an Dokumenten an Ort und Stelle zu ändern.<br>Der Unterschied zwischen <code>$push</code> und <code>$addToSet</code> ist, dass <code>$addToSet</code> ein Element nicht dem Array hinzufügt, wenn es schon vorhanden ist.</aside>
</section>

	<section>
		<h3><code>find + update</code></h3>
		<p class="small">Vor dem Update wird der <em>alte Zustand</em> des Dokuments zurückgeliefert:</p>

		<h4><code>findOneAndUpdate( kriterium, update )</code></h4>
		<pre><code class="javascript">db.kunden.findOneAndUpdate({"_id": 5}, {$set: {geboren:1973}})</code></pre>

		<h4><code>findAndModify({query:{&hellip;}, update:{&hellip;} })</code></h4>
		<pre><code class="javascript">db.kunden.findAndModify({query:{"_id": 5}, 
                         update:{$set: {geboren:1973}}})</code></pre>

<div class="fragment">
		<p class="small">Erhöhe den Preis des günstigsten Produkts um 50ct und gib den neuen Zustand des geänderten Dokuments zurück:</p>
		<pre><code class="javascript">db.produkte.findAndModify({query:{}, sort:{preis:1}, new:true,
                           update:{$inc:{preis:0.5}}})</code></pre>
</div>
</section>

<section>
	<h3>Upsert</h3>
	<p class="small">Einfügen, außer es gibt das Dokument schon, dann ändern!</p>
	<pre><code class="javascript">db.kunden.update({name:"Tina"},
                 {name:"Tina", geboren:1995},
                 {upsert:true})</code></pre>

	<pre><code class="javascript">db.kunden.save({_id:5, name:"Peter", geboren:1995})</code></pre>

  <pre><code class="javascript">db.kunden.findAndModify({query:{name:"Mike"},
              update:{name:"Mike", geboren:1995},
              upsert:true})</code></pre>

	<div class="poll fragment" style="bottom: -270px; width: 9.5cm;">
		<h1>Die untere Query liefert null zurück, warum?</h1>
				<ul>
					<li data-poll="correct">Weil es noch keinen Mike gibt</li>
					<li data-poll="correct">Weil new standardmäßig false ist</li>
					<li data-poll="correct">Weil kein Dokument geändert wurde</li>
					<li data-poll="correct">Weil ein Dokument eingefügt wurde</li>
				</ul>
		<h2></h2>
	</div>

	<aside class="notes">Es gibt in MongoDB mehrere Möglichkeiten, ein Upsert auszuführen. Entweder über die Option <code>{upsert:true}</code> im optionalen dritten Parameter einer <code>update</code>-, <code>updateOne</code>- oder<code>updateMany</code>-Anfrage. Oder man verwendet <code>save</code>, die Methode funktioniert wie <code>insert</code>, ersetzt das Dokument aber, falls schon eins mit der gegebenen <code>_id</code> existiert.</aside>
</section>

<section>
	<h3>Multi-Update</h3>
	<p class="small">Achtung: Alle bisherigen Beispiele updaten immer nur <em>ein</em> Dokument!</p>
		<h4>Multi-Update:</h4>
		<pre><code class="javascript">db.kunden.update({}, {$set: {telefon:[]}}, {multi:true})</code></pre>
		<pre><code class="javascript">db.kunden.updateMany({}, {$set: {telefon:[]}})</code></pre>
		
		<aside class="notes"><code>findAndModify</code> und <code>findOneAndUpdate</code> modifizieren immer nur ein Dokument (das erste, was sie finden können). Auch bei <code>update</code> ist das standardmäßig so, dort lässt sich aber die Option <code>{"multi":true}</code> verwenden, um Änderungen auf allen Dokumenten auszuführen, die das Query-Kriterium erfüllen.</aside>
</section>

<section>
	<h3>Dokumente löschen</h3>
	<h4><code>deleteOne</code></h4>
	<pre><code class="javascript">db.kunden.deleteOne( {"name": "Peter" } )</code></pre>

	<div class="fragment">
	<h4><code>deleteMany</code></h4>
	<pre><code class="javascript">db.kunden.deleteMany( {"geboren": {$lte: 1980} } )</code></pre>
	<pre class="fragment"><code class="javascript">db.kunden.deleteMany( {} )   // löscht alle Kunden</code></pre>
	</div>

	<div class="fragment">
		<h4><code>db.collection.drop()</code></h4>
		<pre><code class="javascript">db.kunden.drop()</code></pre>
	</div>
	
	<aside class="notes">Die oberen drei Kommandos löschen Dokumente aus der Collection, die Collection selbst bleibt aber bestehen. <code>drop()</code> entfernt die komplette Collection samt aller in ihr befindlichen Dokumente. Sollten momentan Indexe auf der zu droppenden Collection im Aufbau sein, wird dieser Vorgang erst gestoppt, dann wird die Collection entfernt.</aside>
</section>

<section>
	<h3>Subdokumente</h3>
	<p class="small" style="width: 103%;"><code class="javascript">{ _id:1, name:"Tina", ​geboren: { jahr: 1995, ort: "Ulm" }}​<br>
{ _id:2, name:"Kai",​ geboren: { jahr: 1980, ort: "Ulm" }}</code></p>


  <h4>Projektion</h4>
	<pre style="margin-top:-5mm; width: 101%;"><code class="javascript">> db.kunden.find({}, {"geboren":{"jahr":1}})
{ "_id" : 1, "geboren" : { "jahr" : 1995 } }
{ "_id" : 2, "geboren" : { "jahr" : 1980 } }</code></pre>

<div class="fragment">
<h4>Selektion</h4>
<pre style="margin-top:-5mm; width: 101%;"><code class="javascript">db.kunden.find({"geboren":{"jahr":1980, "ort":"Ulm"}}) // findet Kai
db.kunden.find({"geboren":{"ort":"Ulm", "jahr":1980}}) // findet nichts
db.kunden.find({"geboren":{"jahr":1980}})              // findet nichts</code></pre>
<p class="small">&Rightarrow; Keine elegante Lösung</p>
</div>

	<aside class="notes">Die hier gezeigten Beispiele für Selektionen sollte man so nicht verwenden. Ein Dokument wird nämlich nur gefunden, wenn es das Subdokument genau wie angegeben enthält (keine weiteren Felder, Felder genau in der Reihenfolge). Auf der nächsten Folie ist der elegantere Weg beschrieben, und zwar mit der Dot-Notation.</aside>
	</section>

<section>
	<h3>Dot-Notation</h3>
	<h4>Projektion mit Dot-Notation</h4>
	<pre style="width: 100%;"><code class="javascript">db.kunden.find({},{"geboren.jahr":1})</code></pre>
	
	<h4>Selektion mit Dot-Notation</h4>
	<pre style="width: 100%;"><code class="javascript">db.kunden.find({"geboren.jahr":1980})                  // findet Kai</code></pre>

	<h4>Änderungen in Subattributen</h4>
	<pre style="width: 100%;"><code class="javascript">db.kunden.update( {_id: 1}, {$set:{"geboren.ort":"Regensburg"}} )</code></pre>
	<aside class="notes"><code>"geboren.jahr"</code> muss unbedingt in Anführungszeichen wegen des Punkts.</aside>

</section>

<section>
	<h3>Arrays</h3>

	<p class="small" style="width: 103%;"><code class="javascript">{ "_id": 17, "bezeichnung": "Schokoriegel", "preis": 0.89,<br>
&nbsp;&nbsp;"kategorien": ["Lebensmittel", "Süßwaren"] }<br>
{ "_id": 88, "bezeichnung": "Katzenfutter", "preis": 3.99,<br>
&nbsp;&nbsp;"kategorien": ["Tierbedarf"] }</code></p>

<h4>Selektion</h4>
<pre style="margin-top:-5mm; width: 100%;"><code class="javascript">db.produkte.find({kategorien:"Lebensmittel"}) // findet Schokoriegel</code></pre>

<h4>Elemente hinzufügen / entfernen</h4>
<pre style="margin-top:-5mm; width: 100%;"><code class="javascript">db.produkte.update({_id: 88}, {$push:{kategorien:"Katze"}})</code></pre>
<pre style="width: 100%;"><code class="javascript">db.produkte.update({_id: 88}, {$addToSet:{kategorien:"Katze"}})</code></pre>
<pre style="width: 100%;"><code class="javascript">db.produkte.update({_id: 88}, {$pull:{kategorien:"Katze"}})</code></pre>
<aside class="notes">Eine normale (Gleichheits-)Selektion überprüft bei Array-Feldern, ob der Wert im Array vorhanden ist. <code>$push</code> fügt ein Element dem Array hinzu. Der Array kann dann Duplikate beinhalten. <code>$addToSet</code> fügt es nur hinzu, wenn es noch nicht drin ist. <code>$pull</code> entfernt alle Vorkommnisse des Elements im Array.</aside>
</section>

<section>
	<h3>Data-Model-Design</h3>
	<p class="small">Es ist wichtig, eine zur Anwendung passende Dokumentenstruktur zu wählen.</p>
	<h4>Embedding (Denormalisierte Speicherung)</h4>
	<p class="small" style="margin-top: -5mm;">
		Alles zusammen speichern, was zusammen gehört. (Limit: 16 MB / Dokument)
	</p>
	<pre style="margin-top: -3mm;"><code class="json">{ "_id": 4, "name":"Ute", 
  "adresse": 
  { "strasse":"Bergstr. 25", "plz": 12345, "ort": "Teststadt" }
}</code></pre>
<p class="small" style="margin-top: -3mm;">
	(+) sehr performant (alles in einem Read-Request), atomare Schreiboperationen.
</p>

<h4>Referenzieren (Normalisierte Speicherung)</h4>
<div class="columns" style="margin-top: -8mm;">
	<div>
		<pre style="width: 9.8cm;"><code class="json">{ "_id": 4, "name":"Ute" }</code></pre>
	</div>
	<div>
		<pre style="width: 14.3cm;"><code class="json">{ "_id": ObjectId("..."), 
"kunde_id":4, "strasse":"Bergstr. 25", 
"plz": 12345, "ort": "Teststadt" }</code></pre>
	</div>

	<aside class="notes">Der untere Ansatz gleicht der typischen Datenmodellierung in relationalen Datenbanken mittels Fremdschlüsseln. In MongoDB ist es aber meist sinnvoller, alles zusammengehörige in ein einziges Dokument einzubetten (z. B. alle Bewertungen in ein Produkt-Dokument, alle Kommentare in ein Blogbeitrag-Element, etc.).</aside>
</div>
</section>

<section>
	<h3>1:N-Beziehungen</h3>
	<div class="columns">
		<div class="erd" style="margin-top:5mm; width: 350px;">
						[[
						 { _e: "Produkt", pos: [30, 100],
							 attributes: [
								{ _a:"Produktnr", pos: [15, 25], options:["primary"] },
								{ _a:"Bezeichnung", pos: [134, 25] },
								{ _a:"Preis", pos: [200, 106] }
							 ]
						 },
						 { _e: "Hersteller", pos: [30, 304],
							 attributes: [
								{ _a:"Firma", pos: [200, 280], options:["primary"] },
								{ _a:"Land", pos: [200, 345] }
							 ]
						 }
						],
						[
						 { _r: "ist von",
							 _e: ["Produkt", "Hersteller"],
							 card: ["N", "1"]      }
						]]
												</div>

												<div class="fragment" style="margin-top: -10mm;">
		
																<pre style="width: 16cm;"><code class="javascript">{                   // Collection "produkte"
 "_id": 17, "bezeichnung": "Schokoriegel", 
 "preis": 0.89, 
 "hersteller": { 
   "firma": "Monsterfood", 
   "land": "USA" 
 }
}</code></pre>
<div class="fragment">
<p class="small" style="margin-top: -3mm; margin-bottom: -3mm;">oder:</p>
<pre style="width: 16cm;"><code class="javascript">{                 // Collection "hersteller"
 "_id": "Monsterfood", "land": "USA",
 "produkte": [ {
  "produktnr": 17,
  "bezeichnung": "Schokoriegel",
  "preis": 0.89
 } ]
}</code></pre></div>

														</div>
										</div>
<aside class="notes">Beide hier gezeigten Ansätze nutzen die denormalisierte Speicherung (Embedding). Daher ist nur eine einzige Kollektion nötig. Der obere Ansatz ist gut, wenn die Anwendung oft Produkte anzeigt samt ihren Herstellerinfos; der untere, wenn oft alle Produkte eines Herstellers gesucht werden. Der untere Ansatz vermeidet Redundanz, da oben derselbe Hersteller an mehreren Stellen stehen wird.</aside>
</section>

<section>
	<h3>Embedding</h3>
	<div class="columns">
		<div class="erd" style="margin-top:5mm; width: 350px; max-height: 8cm;">
						[[
						 { _e: "Produkt", pos: [30, 100],
							 attributes: [
								{ _a:"Produktnr", pos: [15, 25], options:["primary"] },
								{ _a:"Bezeichnung", pos: [134, 25] },
								{ _a:"Preis", pos: [200, 106] },
							  { _a:"Bewertungen", "options": ["multi"], pos: [58, 177],
							     attributes: [
							     	{ _a:"Sterne", pos: [22, 244] },
								    { _a:"Text", pos: [134, 244] }
							     ]
						    }
						]}],
						[
						]]
												</div>

												<div class="fragment" style="margin-top: 0mm;">
		
																<pre style="width: 16cm;"><code class="javascript">{                   // Collection "produkte"
 "_id": 17, 
 "bezeichnung": "Schokoriegel", 
 "preis": 0.89, 
 "bewertungen": [ 
  { "sterne": 3, "text": "Schmeckt okay." },
  { "sterne": 5, "text": "Der Hammer!" }
 ]
}</code></pre>
<div class="fragment">
<p class="small">(-) Dokument kann extrem groß werden.</p>
</div>

								</div>
				</div>

		<div class="fragment">
		<h4>Subset-Pattern</h4>
		<p class="small" style="margin-top: -5mm;">Erste 10 Bewertungen embedden. Separate Collection mit allen Bewertungen.</p>
		<pre style="margin-top: -3mm;"><code class="javascript">{ "_id": ObjectId("..."),           // Collection "bewertungen"
  "produkt_id": 17, "sterne": 3, "text": "Schmeckt okay." }</code></pre>
</div>
	<aside class="notes">Das Subset-Pattern ist ein Kompromiss. Man kann mit einer Anfrage sehr performant die Produktdetails und die ersten 10 Bewertungen abrufen. Dennoch bleiben die Dokumente klein. Wegen der doppelten Speicherungen müssen manche Bewertungen aber an mehreren Stellen bearbeitet werden.</aside>
</section>

<section>
	<h3>N:M-Beziehungen</h3>
	<div class="columns">
		<div class="erd" style="margin-top:5mm; width: 350px;">
						[[
						 { _e: "Produkt", pos: [30, 100],
							 attributes: [
								{ _a:"Produktnr", pos: [15, 25], options:["primary"] },
								{ _a:"Bezeichnung", pos: [134, 25] },
								{ _a:"Preis", pos: [200, 106] }
							 ]
						 },
						 { _e: "Händler", pos: [30, 304],
							 attributes: [
								{ _a:"Händler", pos: [200, 280], options:["primary"] },
								{ _a:"Telefon", pos: [200, 345], options:["multi"] }
							 ]
						 }
						],
						[
						 { _r: "wird\nangeboten\nvon",
							 _e: ["Produkt", "Händler"],
							 card: ["N", "M"]      }
						]]
												</div>

												<div class="fragment" style="margin-top: -10mm;">
		
																<pre style="width: 16cm;"><code class="javascript">{          // Collection "haendler_produkte"
 "_id": 
 {"produkt_id": 17, "haendler_id": 101}
}</code></pre>
<div class="fragment">
<p class="small" style="margin-top: -4mm; margin-bottom: -4mm;">oder:</p>
<pre style="width: 16cm;"><code class="javascript">{                   // Collection "haendler"
 "_id": "Shop25", "telefon": ["0171123"],
 "produkte": [ 17, 18, 29 ]
}</code></pre></div>
<div class="fragment">
<p class="small" style="margin-top: -4mm; margin-bottom: -4mm;">oder:</p>
<pre style="width: 16cm;"><code class="javascript">{                   // Collection "produkte"
 "_id": 17, "bezeichnung": "Schokoriegel", 
 "preis": 0.89, "haendler": [ "Shop25", "Q" ]
}</code></pre></div>

<div class="fragment">
	<p class="small" style="margin-top: -4mm; margin-bottom: -4mm;">oder: 2-way Embedding (die unteren 2 Varianten).</p>

	<aside class="notes">Die obere Modellierung ähnelt dem Ansatz aus relationalen DBs. In dem Fall wird zusätzlich eine Produkte- und eine Händler-Collection benötigt. Damit splittet man die N:M-Beziehung in zwei 1:N-Beziehungen. Die anderen Ansätze verwenden Arrays mit Referenzen. Hier muss man sich entscheiden, ob man zu jedem Produkt die Händler finden will, zu jedem Händler seine Produkte oder beides.</aside>
														</div>
										</div>
</section>

<section>
	<h3>Baumstrukturen</h3>
	<div class="columns">
		<div style="margin-top:5mm; width: 350px;">
						<img src="img/2/er_unterkategorie.png" alt="Rekursive Beziehung" class="noborder" style="width: 200px;">
												</div>

												<div class="fragment" style="width: 16cm;">
														<h4 style="margin-bottom: -5mm;">Parent-Referenz:</h4>
														<pre style="width: 16cm;"><code class="javascript">{ "_id": "Saft", "parent": "Getränke" }</code></pre>

														<div class="fragment">
															<h4 style="margin-bottom: -5mm;">Child-Referenzen:</h4>
															<pre style="width: 16cm;"><code class="javascript">{ "_id": "Getränke", 
  "children": ["Saft", "Wasser", "Bier"] }</code></pre>
															</div>

															<div class="fragment">
																<h4 style="margin-bottom: -5mm;">Array mit Vorfahren:</h4>
																<pre style="width: 16cm;"><code class="javascript">{ "_id": "Saft", "parent": "Getränke",
"ancestors": ["Lebensmittel", "Getränke"] }</code></pre>
																</div>
														</div>
										</div>
<aside class="notes">Die oberste Kategorie hat <code>"parent":null</code>, die Blätter des Baumes <code>children:[]</code>. Sowohl Parent- als auch Child-Referenzen eignen sich, um schnell die Ober- als auch Unterkategorie einer Kategorie zu finden. Der untere Ansatz (Array mit Vorfahren) eignet sich, um schnell, alle Überkategorien. Auch alle Unterkategorien sind schnell gefunden: <code>db.kategorien.find({"ancestors":"Lebensmittel"})</code> Es wurde zusätzlich das Feld <code>parent</code> eingeführt, um die direkte Überkategorie anzugeben.<br>
Die auf dieser und den vorherigen Folien präsentierten Modellierungsalternativen sind nicht vollständig. Es gibt noch jede Menge weitere Möglichkeiten, gleiche Sachverhalte zu modellieren, mit jeweils ihren Vor- und Nachteilen.</aside>
</section>

			</div>
		</div>

		<script src="reveal.js/dist/reveal.js"></script>
		<script src="reveal.js/plugin/markdown/markdown.js"></script>
		<script src="reveal.js/plugin/highlight/highlight.js"></script>
		<script src="reveal.js/plugin/zoom/zoom.js"></script>
		<script src="reveal.js/plugin/math/math.js"></script>
		<script src="reveal.js/plugin/notes/notes.js"></script>
		<script src="reveal.js/plugin/search/search.js"></script>
        <script src="lib/jquery.js"></script>
        <script src="lib/lodash.js"></script>
        <script src="lib/backbone.js"></script>
        <script src="lib/joint.min.js"></script>
				<script src="lib/deflate.js"></script>

		<script src="src/init_reveal.js"></script>

        <script>
        if(window.location.search.match( /print-pdf/gi )) {
                document.getElementById('header').style="display:none";
                document.getElementById('footer').style="display:none";
        }
        </script>


	</body>
</html>
